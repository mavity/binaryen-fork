# Binaryen Rust Conversion - Technical Specifications

## Overview

This document provides detailed technical specifications for converting Binaryen components to Rust. It includes code patterns, FFI strategies, safety considerations, and implementation guidelines.

## FFI Patterns

### Basic Opaque Types

When exposing Rust types to C/C++, use opaque pointers with explicit create/dispose functions:

```rust
// Rust side - Internal type
pub struct Module {
    functions: Vec<Function>,
    // ... other fields
}

### C++ shim patterns

When calling into Rust from C++, prefer small shim headers that hide `extern "C"` names behind a C++-friendly API and can be toggled with the `BUILD_RUST_COMPONENTS` CMake option.

- Example shim: `src/support/strings_rust.h` exposes `BinaryenStringInternerCreate`/`Dispose`/`Intern` as `BinaryenStringInternerCreateWrapper` etc., and compiles with and without `BUILD_RUST_COMPONENTS` defined.
- We provide a simple template `src/support/rust_shim_template.h` that shows the pattern to forward to Rust and provide a C++ fallback when `BUILD_RUST_COMPONENTS` is disabled.

// Opaque handle for C
#[repr(C)]
pub struct BinaryenModuleRef {
    _private: [u8; 0],
}

#[no_mangle]
pub extern "C" fn BinaryenModuleCreate() -> *mut BinaryenModuleRef {
    let module = Box::new(Module::new());
    Box::into_raw(module) as *mut BinaryenModuleRef
}

#[no_mangle]
pub extern "C" fn BinaryenModuleDispose(module: *mut BinaryenModuleRef) {
    if !module.is_null() {
        unsafe { 
            let _ = Box::from_raw(module as *mut Module);
        }
    }
}
```

## Memory Management

### Arena Allocation

Binaryen uses arena allocation for IR nodes. Rust equivalent using `bumpalo`:

```rust
use bumpalo::Bump;

pub struct ModuleArena {
    bump: Bump,
}

impl ModuleArena {
    pub fn new() -> Self {
        Self { bump: Bump::new() }
    }
    
    pub fn alloc<T>(&self, value: T) -> &mut T {
        self.bump.alloc(value)
    }
}
```

## Testing Strategy

### Validation at Each Phase

1. **Unit Tests**: Test individual components
2. **Integration Tests**: Test component interactions  
3. **Regression Tests**: Ensure no functionality breaks
4. **Performance Tests**: Benchmark against C++
5. **Fuzzing**: Find edge cases
6. **Property Tests**: Validate invariants

## Validation Checklist

Before considering a component complete:

- [ ] All unit tests pass
- [ ] Integration tests pass
- [ ] Benchmarks show acceptable performance
- [ ] Miri clean (no undefined behavior)
- [ ] Clippy clean (no warnings)
- [ ] Documentation complete
- [ ] FFI tested with C++
- [ ] Memory leaks checked
- [ ] Fuzz testing run
- [ ] Code review completed

## References

- [The Rustonomicon](https://doc.rust-lang.org/nomicon/)
- [Rust FFI Omnibus](http://jakegoulding.com/rust-ffi-omnibus/)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [WebAssembly Specification](https://webassembly.github.io/spec/)

## ABI stability and gating

The FFI contract is defined by the C header generated by `cbindgen` for the `binaryen-ffi` crate. The canonical header file is `include/binaryen_ffi.h` and must be kept stable across PRs that claim not to change the FFI.

### Golden header & cbindgen

- To verify the cbindgen output against the golden header, run:

    ```bash
    rust/scripts/check_cbindgen.sh
    ```

    This script regenerates the header from the Rust crate `rust/binaryen-ffi` and diffs it against `include/binaryen_ffi.h`. If the header changes, the script fails and you must either revert the Rust-side change or intentionally update the golden header.

- If you intend to change the ABI (shape, names, types or ownership semantics), do the following:
    1. Update the rust code in `rust/binaryen-ffi` and rerun `rust/scripts/check_cbindgen.sh` locally.  
 2. Update `include/binaryen_ffi.h` with the new header generated by `cbindgen` (commit the new header).  
 3. Document the reason and backwards-incompatibility in the PR description and in this docs section (`docs/rust/vision/…`).  
 4. Request sign-off from ABI owners (see "Reviewers & sign-off" below).  

> Note: Do not update the golden header without clearly stating why the ABI changed and who reviewed it.

### ABI version macro

We maintain a small integer ABI macro in the generated header that identifies a stable ABI version. The canonical name is `BINARYEN_FFI_ABI_VERSION` and it appears in `include/binaryen_ffi.h`.

- To change the ABI, bump the constant in Rust (`rust/binaryen-ffi/src/lib.rs`) and regenerate header with `rust/scripts/update_cbindgen.sh`.
- The `test/rust_consumer` smoke-consumer includes a compile-time check to ensure `BINARYEN_FFI_ABI_VERSION` matches the repository's expected value; if this check fails, the PR should not land until owners approve the change.

**Auto-generating the ABI macro with cbindgen (optional)**

If you prefer to generate the `BINARYEN_FFI_ABI_VERSION` macro from Rust automatically, you can:

1. Add a public Rust constant (already present):

    ```rust
    pub const BINARYEN_FFI_ABI_VERSION: u32 = 1;
    ```

2. Configure `cbindgen` to include constants (typically cbindgen emits `static` constants; you can also adjust `cbindgen.toml` to output macros).

3. Run `rust/scripts/update_cbindgen.sh` and review the resulting `include/binaryen_ffi.h` to ensure the `BINARYEN_FFI_ABI_VERSION` symbol is present in the form you want.

Note: we keep the golden header under source control. If you auto-generate the macro with `cbindgen`, be sure the generated macro is in the expected C-friendly form (for example, `#define BINARYEN_FFI_ABI_VERSION 1`). If cbindgen emits a `static const` symbol, you can adapt the smoke-consumer to compare the runtime function instead of a C macro.

### Local validation steps

1. Enable building and tests with Rust components in CMake:

     ```bash
     cmake -S . -B build -DBUILD_RUST_COMPONENTS=ON -DBUILD_TESTS=ON
     cmake --build build
     ```

2. Run the smoke consumer test which exercises the FFI and checks for runtime semantics:

     ```bash
     ctest -R rust_ffi_smoke -V
     ```

3. Run cbindgen script to ensure the header matches the golden copy:

    ```bash
    rust/scripts/check_cbindgen.sh
  # or regenerate and update the golden header (only if you intentionally changed the ABI):
    rust/scripts/update_cbindgen.sh
  ```

4. If you changed signatures and want to also update tests, run the `test/rust_consumer` smoke consumer and any other integration tests that rely on the FFI.

4.1. You may validate `ctest` integration locally — the `rust_ffi_smoke` test is available when `-DBUILD_RUST_COMPONENTS=ON` and `-DBUILD_TESTS=ON`:

```bash
cmake -S . -B build -DBUILD_RUST_COMPONENTS=ON -DBUILD_TESTS=ON
cmake --build build --target rust_libs
# Build targets and tests (may be `cmake --build build --target check` depending on platform)
ctest -R rust_ffi_smoke -V
```

### Backwards-compatibility policy

- We aim to keep the ABI stable unless there's a clear benefit. When breaking changes are unavoidable, update the golden header and request an incremental migration plan. Example strategies include:
    - Add new symbols and keep old ones (deprecation window).
    - Keep old types and provide conversions where possible.

## Reviewers & sign-off guidance

The golden header and build helper `cmake/BinaryenRust.cmake` affect interop between Rust and C++.

- Who to involve:
    - `Team Libs` (team owning low-level utilities) — validate memory management contract and ownership rules.
    - `Rust maintainers` — ensure idiomatic and safe Rust patterns.
    - `Consumers` (teams using FFI) — validate forward compatibility with downstream code.

- Sign-off checklist for ABI changes:
    1. Add a clear description of the ABI change and why it is necessary in the PR.  
    2. Mention affected header symbols and ownership/ownership-changes.  
    3. Run `rust/scripts/check_cbindgen.sh` locally, and include the command output in the PR if the header changed.  
    4. Update `include/binaryen_ffi.h` and the `docs/rust` section to explain the change.  
    5. Request explicit approval from the owners listed above.

### Suggested PR gating checklist for ABI changes

- Make sure `rust/scripts/check_cbindgen.sh` and `rust/scripts/check_abi_changes.sh` pass locally.
- If you intend to change the ABI, add a changelog entry clarifying the change and the reason.
- Bump `BINARYEN_FFI_ABI_VERSION` in both `include/binaryen_ffi.h` and `rust/binaryen-ffi/src/lib.rs`.
- Add automated tests demonstrating backward-incompatible behavior or the migration path.
- Request review by: (fill in maintainers) `@org/rust-maintainers`, `@org/libs-maintainers`.

> Note: We intentionally avoid `CODEOWNERS` gating until we finalize owner membership; please assign reviewers accordingly in the PR description.

Sample `CODEOWNERS` snippet to gate ABI changes (do not add automatically — this is guidance you can apply):

```
# Require review by rust and libs maintainers for FFI headers and rust/CMake glue
/include/binaryen_ffi.h @org/rust-maintainers @org/libs-maintainers
/cmake/BinaryenRust.cmake @org/rust-maintainers @org/cmake-maintainers
```

Add repository `CODEOWNERS` entries only after the team agrees on the membership to be notified for ABI changes.
