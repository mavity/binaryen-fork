# Plan: Master Opcode Implementation Plan (1.3.1)

This plan ensures comprehensive coverage of the WebAssembly MVP specification in `binaryen-ir`, addressing the "Opcode Debt" that blocks testing.

## Phase A: Core Definitions Update
Before implementing the writer, we must ensure `expression.rs` and `ops.rs` rely on complete definitions.

### 1. Update `ops.rs` - Unary Operations
Add the following missing variants to `enum UnaryOp`:
*   **Conversions (Integer <-> Float)**:
    *   `ConvertSInt32ToFloat32`, `ConvertUInt32ToFloat32`, `ConvertSInt64ToFloat32`, `ConvertUInt64ToFloat32`
    *   `ConvertSInt32ToFloat64`, `ConvertUInt32ToFloat64`, `ConvertSInt64ToFloat64`, `ConvertUInt64ToFloat64`
    *   `TruncSFloat32ToInt32`, `TruncUFloat32ToInt32`, `TruncSFloat64ToInt32`, `TruncUFloat64ToInt32`
    *   `TruncSFloat32ToInt64`, `TruncUFloat32ToInt64`, `TruncSFloat64ToInt64`, `TruncUFloat64ToInt64`
*   **Conversions (Integer <-> Integer)**:
    *   `WrapInt64`, `ExtendSInt32`, `ExtendUInt32`
*   **Conversions (Float <-> Float)**:
    *   `PromoteFloat32`, `DemoteFloat64`
*   **Reinterprets**:
    *   `ReinterpretFloat32`, `ReinterpretFloat64`, `ReinterpretInt32`, `ReinterpretInt64`
*   **Sign Extensions** (Post-MVP but standard):
    *   `ExtendS8Int32`, `ExtendS16Int32`, `ExtendS8Int64`, `ExtendS16Int64`, `ExtendS32Int64`

### 2. Update `expression.rs` - ExpressionKind
Add missing variants to `enum ExpressionKind`:
*   `Switch` (for `br_table`):
    ```rust
    Switch {
        names: BumpVec<'a, &'a str>, // List of target labels
        default: &'a str,           // Default label
        condition: ExprRef<'a>,     // Index
        value: Option<ExprRef<'a>>, // Value passing (nullable)
    }
    ```
*   `CallIndirect`:
    ```rust
    CallIndirect {
        table: &'a str,
        target: ExprRef<'a>,       // Function index
        operands: BumpVec<'a, ExprRef<'a>>,
        type_: Type,               // Signature
    }
    ```
*   `MemoryGrow`:
    ```rust
    MemoryGrow {
        delta: ExprRef<'a>,
    }
    ```
*   `MemorySize`:
    ```rust
    MemorySize
    ```

## Phase B: BinaryWriter Implementation
Implement the logic to serialize the expanded IR into Wasm bytecode.

### 1. Fix Load/Store Logic
*   **Context**: Current implementation assumes integer loads/stores based only on size.
*   **Fix**: Use `expr.type_` to distinguish Float loads/stores.
    *   `f32.load` (0x2A), `f64.load` (0x2B)
    *   `f32.store` (0x38), `f64.store` (0x39)
*   **Missing Integers**: Implement `i64.load8_s/u`, `i64.load16_s/u`, `i64.load32_s/u`, `i64.store8/16/32`.

### 2. Implement Unary Operations
Update `write_expression` to handle `ExpressionKind::Unary`:
*   **Bitwise**: `clz`, `ctz`, `popcnt` (i32/i64)
*   **Float Math**: `abs`, `neg`, `ceil`, `floor`, `trunc`, `nearest`, `sqrt`
*   **Conversions**: Map all new `UnaryOp` variants to their respective opcodes (e.g., `i32.wrap_i64` -> 0xA7).

### 3. Implement Binary Operations
Complete the `BinaryOp` match arm:
*   **Integer Math**: `div_s`, `div_u`, `rem_s`, `rem_u`
*   **Integer Bitwise**: `and`, `or`, `xor`, `shl`, `shr_s`, `shr_u`, `rotl`, `rotr`
*   **Comparisons**: `eq`, `ne`, `lt_s/u`, `gt_s/u`, `le_s/u`, `ge_s/u` (for i32 and i64)
*   **Float Math**: `div`, `min`, `max`, `copysign`
*   **Float Comparison**: `eq`, `ne`, `lt`, `gt`, `le`, `ge`

### 4. Implement New Control/Memory Kinds
*   `Switch`: Serialize as `br_table` (0x0E). Requires vector of label indices.
*   `CallIndirect`: Serialize as `call_indirect` (0x11). Requires `type_idx` and `table_idx` (0x00).
*   `MemorySize`: Serialize as `memory.size` (0x3F) + `0x00`.
*   `MemoryGrow`: Serialize as `memory.grow` (0x40) + `0x00`.

## Phase C: Validation & Testing
1.  **Phase 3 Tests**: i32/i64 tests should pass after Phase B.3.
2.  **Phase 4 Tests (Floats)**: Should pass after Phase B.2/B.3.
3.  **Phase 5 Tests (Conversions)**: Should pass after Phase A.1 + B.2.
4.  **Phase 6 Tests (Memory)**: Should pass after Phase B.1 + B.4.

## Edge Cases to Watch
*   **Alignment encoding**: Ensure alignment is encoded as `log2(align)`.
*   `br_table` with values: Ensure value is on stack.
*   `call_indirect`: Type index management (might need to register the type signature in Type section).
*   `atomic` operations: Explicitly out of scope for now (0-vision alignment).

