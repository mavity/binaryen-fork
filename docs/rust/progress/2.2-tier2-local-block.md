# Tier 2: Local & Block Optimizations
**Status**: üìã Planned | **Passes**: 24 | **Estimated Effort**: 3‚Äì4 weeks | **Target**: Week 3-5

---

## Overview

Tier 2 focuses on **single-function optimizations** that work within individual functions without requiring whole-module analysis. These passes share common infrastructure for tracking local variables, analyzing control flow, and performing safe code motion.

**Key Characteristics**:
- Operate on a single function at a time
- Require control flow graph (CFG) and dominance analysis
- Use effect analysis (already implemented) for safety
- Build on Tier 1's cleanup (unused elements already removed)

**Critical Prerequisite**: ‚ö†Ô∏è **Arena-based expression manipulation** must be implemented first to enable tree restructuring. See "Critical Architectural Task" section in main gap analysis.

---

## Group 2A: Local Simplification & Sinking

**Passes**: 8 | **Effort**: 18-24 days | **Dependencies**: Arena migration (critical blocker)

### Pass List
1. **simplify-locals** (‚ö†Ô∏è partially done) ‚Äî Sink local.sets, create tees, optimize structure
2. **coalesce-locals** (‚úÖ done) ‚Äî Merge non-overlapping locals
3. **local-cse** ‚Äî Local common subexpression elimination
4. **local-subtyping** ‚Äî Refine local types to more specific subtypes
5. **untee** ‚Äî Convert local.tees back to sets+gets
6. **merge-locals** ‚Äî Merge similar local patterns
7. **dae** (dead-argument-elimination) ‚Äî Remove unused function parameters
8. **dae-optimizing** ‚Äî DAE + optimize where we removed args

### Shared Infrastructure

**LocalGraph** (2-3 days, reusable):
```rust
// rust/binaryen-ir/src/analysis/local_graph.rs

/// Represents def-use chains for locals within a function
pub struct LocalGraph {
    /// Maps local ID to all definitions (local.set, local.tee, param)
    definitions: HashMap<LocalId, Vec<ExprRef>>,
    
    /// Maps local ID to all uses (local.get)
    uses: HashMap<LocalId, Vec<ExprRef>>,
    
    /// Liveness information (which locals are live at each point)
    liveness: HashMap<ExprRef, HashSet<LocalId>>,
}

impl LocalGraph {
    pub fn build(func: &Function) -> Self { /* ... */ }
    
    /// Can we safely move this local.set to a different location?
    pub fn can_sink(&self, set: ExprRef, target: ExprRef) -> bool {
        // Check: No interfering effects between set and target
        // Check: Target dominates all uses
        // Check: No other definitions between set and target
    }
    
    /// Find all uses of a local within a subtree
    pub fn find_uses_in(&self, local: LocalId, expr: ExprRef) -> Vec<ExprRef> { /* ... */ }
}
```

**Dominance Analysis** (2 days, reusable for Group 2B):
```rust
// rust/binaryen-ir/src/analysis/dominance.rs

pub struct DominanceTree {
    /// Maps expression to its immediate dominator
    idom: HashMap<ExprRef, ExprRef>,
    
    /// Cached dominance relationships
    dominates_cache: HashMap<(ExprRef, ExprRef), bool>,
}

impl DominanceTree {
    pub fn build(func: &Function) -> Self { /* ... */ }
    
    /// Does `dominator` dominate `dominated`?
    pub fn dominates(&self, dominator: ExprRef, dominated: ExprRef) -> bool { /* ... */ }
    
    /// Find lowest common ancestor in dominator tree
    pub fn lca(&self, a: ExprRef, b: ExprRef) -> ExprRef { /* ... */ }
}
```

### Pass Implementation Details

#### simplify-locals (Foundation exists, needs tree manipulation)

**Status**: Foundation complete (Jan 15, 2026), needs arena migration for transformations

**What's Done**:
- ‚úÖ Pass infrastructure (3 modes: allow_tee, allow_structure, allow_nesting)
- ‚úÖ FunctionContext tracking sinkables and use counts
- ‚úÖ Effect-based invalidation
- ‚úÖ Multi-cycle optimization framework

**What's Needed** (requires arena):
```rust
// Sink local.set closer to its uses
fn sink_set(&mut self, set_ref: ExprRef, target_ref: ExprRef) {
    // 1. Extract value from set
    let value = set_ref.get_value();
    
    // 2. Replace set with nop (or drop if value has effects)
    self.arena.replace(set_ref, Expression::nop());
    
    // 3. Insert set at target location
    self.arena.insert_before(target_ref, Expression::local_set(local_id, value));
}

// Create tee for multiple uses
fn create_tee(&mut self, set_ref: ExprRef, first_use: ExprRef) {
    let local_id = set_ref.get_local_id();
    let value = set_ref.get_value();
    
    // Replace first get with tee
    self.arena.replace(first_use, Expression::local_tee(local_id, value));
    
    // Remove original set
    self.arena.replace(set_ref, Expression::nop());
}

// Hoist to block return
fn hoist_to_block_return(&mut self, block_ref: ExprRef, common_value: ExprRef) {
    // Extract common value from all branches
    // Replace with local.get in each branch
    // Add local.set + return value after block
}
```

**C++ Reference**: `src/passes/SimplifyLocals.cpp` (~800 lines)

**Testing**:
```rust
#[test]
fn test_sink_set_closer_to_use() {
    let bump = Bump::new();
    let mut builder = IrBuilder::new(&bump);
    
    // Before: (block (local.set $x (i32.const 42)) (nop) (local.get $x))
    let set = builder.local_set(0, builder.const_i32(42));
    let get = builder.local_get(0);
    let block = builder.block(None, vec![set, builder.nop(), get], Type::I32);
    
    let mut pass = SimplifyLocals::new();
    pass.run_on_function(&mut func);
    
    // After: (block (nop) (local.tee $x (i32.const 42)))
    // Verification: set moved next to use and converted to tee
}
```

---

#### local-cse (3-4 days)

**Purpose**: Eliminate redundant computations within a basic block

**Algorithm**:
1. Build LocalGraph + expression value numbering
2. Walk expression tree in linear order
3. For each expression, check if identical computation already exists
4. If found and no interfering effects, replace with local.get of cached result

**Example**:
```wasm
;; Before:
(block
  (i32.add (local.get $x) (local.get $y))  ;; Computed once
  (drop (i32.add (local.get $x) (local.get $y)))  ;; Redundant
)

;; After:
(block
  (local.tee $temp (i32.add (local.get $x) (local.get $y)))
  (drop (local.get $temp))
)
```

**C++ Reference**: `src/passes/LocalCSE.cpp` (~300 lines)

---

#### local-subtyping (2-3 days)

**Purpose**: Refine local variable types to more specific subtypes (for GC types)

**Algorithm**:
1. Analyze all assignments to each local
2. Compute least upper bound (LUB) of all assigned types
3. If LUB is more specific than declared type, update declaration
4. Helpful for GC where (ref $Animal) can be refined to (ref $Dog)

**C++ Reference**: `src/passes/LocalSubtyping.cpp` (~250 lines)

---

#### dead-argument-elimination (3-4 days each for dae + dae-optimizing)

**Purpose**: Remove unused function parameters

**Algorithm**:
1. Scan function body for uses of each parameter
2. If parameter never used, remove it
3. Update all call sites to not pass that argument
4. dae-optimizing: After removal, run local optimizations on callers

**Example**:
```wasm
;; Before:
(func $foo (param $used i32) (param $unused i32)
  (local.get $used)  ;; $unused never referenced
)
(call $foo (i32.const 1) (i32.const 2))

;; After:
(func $foo (param $used i32)
  (local.get $used)
)
(call $foo (i32.const 1))  ;; Second arg removed
```

**C++ Reference**: `src/passes/DAE.cpp` (~400 lines), `src/passes/DAEOptimizing.cpp` (~450 lines)

---

### Implementation Sequence

**Week 3, Day 1-2**: Infrastructure
- Implement LocalGraph
- Implement DominanceTree
- Write comprehensive unit tests

**Week 3, Day 3-5**: SimplifyLocals completion
- Implement sinking (requires arena)
- Implement tee creation
- Implement block return value optimization

**Week 4, Day 1-2**: LocalCSE
- Implement value numbering
- Implement CSE algorithm
- Test with various expression patterns

**Week 4, Day 3-5**: Remaining simple passes
- Day 3: local-subtyping
- Day 4: untee + merge-locals
- Day 5: dae (basic version)

**Week 5, Day 1**: dae-optimizing + Group 2A polish

---

## Group 2B: Block & Control Flow Merging

**Passes**: 8 | **Effort**: 25-32 days | **Dependencies**: DominanceTree (from 2A)

### Pass List
1. **merge-blocks** ‚Äî Combine sequential blocks
2. **simplify-control-flow** ‚Äî Flatten nested structures, remove empty blocks
3. **rereloop** ‚Äî Convert irreducible CFG back to structured form
4. **poppify** ‚Äî Optimize pop/drop patterns in stack machine code
5. **rse** (redundant-set-elimination) ‚Äî Remove redundant local.sets
6. **flatten** ‚Äî Convert nested blocks to flat IR (needed for DataFlowOpts)
7. **code-pushing** ‚Äî Move code closer to uses without crossing barriers
8. **licm** (loop-invariant-code-motion) ‚Äî Hoist invariants out of loops

### Shared Infrastructure

**ControlFlowGraph** (2-3 days, reusable):
```rust
// rust/binaryen-ir/src/analysis/cfg.rs

pub struct ControlFlowGraph {
    /// Basic blocks (sequences of instructions without control flow)
    blocks: Vec<BasicBlock>,
    
    /// Edges between blocks
    edges: Vec<(BlockId, BlockId)>,
    
    /// Which blocks are loop headers
    loop_headers: HashSet<BlockId>,
    
    /// Backedges (for loop detection)
    backedges: Vec<(BlockId, BlockId)>,
}

impl ControlFlowGraph {
    pub fn build(func: &Function) -> Self { /* ... */ }
    
    pub fn successors(&self, block: BlockId) -> &[BlockId] { /* ... */ }
    pub fn predecessors(&self, block: BlockId) -> &[BlockId] { /* ... */ }
    
    /// Is this CFG reducible (structured)?
    pub fn is_reducible(&self) -> bool { /* ... */ }
    
    /// Find natural loops
    pub fn find_loops(&self) -> Vec<Loop> { /* ... */ }
}

pub struct Loop {
    pub header: BlockId,
    pub body: HashSet<BlockId>,
    pub exits: Vec<BlockId>,
}
```

### Pass Implementation Details

#### merge-blocks (4-5 days)

**Purpose**: Combine consecutive blocks into single block

**Algorithm**:
1. Build CFG
2. Find blocks with single predecessor and single successor
3. Merge instructions into single block
4. Update block type to combined type
5. Fix up branch targets

**Example**:
```wasm
;; Before:
(block $a
  (local.set $x (i32.const 1))
  (br $a)
)
(block $b
  (local.get $x)
)

;; After:
(block $merged
  (local.set $x (i32.const 1))
  (local.get $x)
)
```

**C++ Reference**: `src/passes/MergeBlocks.cpp` (~300 lines)

---

#### simplify-control-flow (3-4 days)

**Purpose**: Remove empty blocks, flatten unnecessary nesting

**Patterns**:
- Empty `if` with no else ‚Üí remove
- `if` with identical then/else ‚Üí extract common code
- Nested blocks with no intermediate code ‚Üí flatten

**C++ Reference**: `src/passes/SimplifyControlFlow.cpp` (name varies, check for similar patterns)

---

#### rereloop (5-7 days, complex)

**Purpose**: Convert irreducible CFG (goto-style) back to structured control flow (if/loop/block)

**Algorithm**:
1. Build CFG and identify irreducible regions
2. Apply node splitting to make reducible
3. Reconstruct structured control flow using Relooper algorithm
4. Emit WebAssembly block/if/loop structures

**Note**: This is one of the most complex passes. May require studying Relooper algorithm in detail.

**C++ Reference**: `src/passes/ReReloop.cpp` (~600 lines) + `src/cfg/Relooper.cpp` (~1500 lines)

---

#### licm (4-5 days)

**Purpose**: Move loop-invariant computations out of loops

**Algorithm**:
1. Build CFG and identify loops
2. Build dominance tree
3. For each instruction in loop body:
   - Check if operands are invariant (not modified in loop)
   - Check if it has no side effects that prevent hoisting
   - Check if it dominates all loop exits
4. Move to loop preheader

**Example**:
```wasm
;; Before:
(loop $L
  (local.set $y (i32.mul (local.get $const_x) (i32.const 10)))  ;; Invariant!
  (local.set $z (i32.add (local.get $y) (local.get $i)))
  (br_if $L (i32.lt_u (local.get $i) (i32.const 100)))
)

;; After:
(local.set $y (i32.mul (local.get $const_x) (i32.const 10)))  ;; Hoisted out
(loop $L
  (local.set $z (i32.add (local.get $y) (local.get $i)))
  (br_if $L (i32.lt_u (local.get $i) (i32.const 100)))
)
```

**C++ Reference**: `src/passes/LICM.cpp` (~350 lines)

---

### Implementation Sequence

**Week 5, Day 2-5**: CFG + first passes
- Day 2: Implement ControlFlowGraph
- Day 3-4: merge-blocks (complex, many edge cases)
- Day 5: simplify-control-flow

**Week 6, Day 1-5**: Advanced control flow
- Day 1-3: rereloop (most complex pass in this group)
- Day 4: poppify + rse
- Day 5: flatten

**Week 7, Day 1-2**: Code motion
- Day 1: code-pushing
- Day 2: licm (uses dominance from 2A)

---

## Group 2C: Index & Memory Locals

**Passes**: 8 | **Effort**: 16-24 days | **Dependencies**: Type system enhancements

### Pass List
1. **pick-load-signs** ‚Äî Infer optimal signedness for loads
2. **signext-lowering** ‚Äî Lower sign-extension operations to MVP
3. **avoid-reinterprets** ‚Äî Prevent unsafe type punning
4. **optimize-added-constants** / **optimize-added-constants-propagate** ‚Äî Fold constant offsets into loads/stores
5. **ssa** / **ssa-nomerge** ‚Äî Convert to SSA form
6. **instrument-locals** ‚Äî Add instrumentation for debugging
7. **trap-mode-clamp** / **trap-mode-js** ‚Äî Configurable trap behavior

### Implementation Notes

These passes are more specialized and independent than Groups 2A/2B. They don't share as much infrastructure but are still simpler than Tier 3+ passes.

#### pick-load-signs (2-3 days)

**Purpose**: Determine whether loads should be sign-extended or zero-extended based on usage

**Algorithm**:
1. Analyze how loaded value is used
2. If only used with operations that don't care about sign, pick zero-extend (cheaper)
3. If sign matters, pick sign-extend

**C++ Reference**: `src/passes/PickLoadSigns.cpp` (~200 lines)

---

#### optimize-added-constants (2-3 days each)

**Purpose**: Merge constant additions into load/store offsets

**Example**:
```wasm
;; Before:
(i32.load (i32.add (local.get $ptr) (i32.const 8)))

;; After:
(i32.load offset=8 (local.get $ptr))
```

**Propagate version**: Also propagates through locals

**C++ Reference**: `src/passes/OptimizeAddedConstants.cpp` (~300 lines)

---

#### ssa / ssa-nomerge (3-4 days each)

**Purpose**: Convert to SSA (Static Single Assignment) form

**Algorithm**:
1. Insert phi nodes at control flow merge points
2. Rename locals so each has single definition
3. ssa-nomerge: Skip merges (simpler, useful for some optimizations)

**Note**: This unlocks advanced data flow analysis in Tier 4

**C++ Reference**: `src/passes/SSAify.cpp` (~450 lines)

---

### Implementation Sequence

**Week 7, Day 3-5**:
- Day 3: pick-load-signs
- Day 4: optimize-added-constants (basic)
- Day 5: optimize-added-constants-propagate

**Week 8, Day 1-5**:
- Day 1-2: ssa-nomerge (simpler version)
- Day 3-4: ssa (full version with phi nodes)
- Day 5: signext-lowering + avoid-reinterprets

**Week 9, Day 1**: Group 2C polish
- instrument-locals
- trap-mode-* passes
- Testing and documentation

---

## Tier 2 Integration & Testing

### Validation Strategy

**After each group**:
- [ ] Run all passes on real-world WebAssembly modules
- [ ] Validate output with official WebAssembly validator
- [ ] Compare binary size before/after
- [ ] Benchmark pass execution time

### Test Suite Requirements

**Unit tests** (‚â•3 per pass):
- Basic functionality test
- Edge case test (empty function, single instruction, etc.)
- Preservation test (module with no optimization opportunities)

**Integration tests**:
- Chain multiple Tier 2 passes together
- Verify passes compose correctly (order independence where applicable)
- Test on real-world modules (e.g., from Emscripten output)

### Fuzzing

Add fuzzer targets:
- Generate random functions
- Apply random subset of Tier 2 passes
- Validate output after each pass
- Catch crashes and validation failures

---

## Success Criteria

### Quantitative
- ‚úÖ 24 passes implemented (6 ‚Üí 30 total)
- ‚úÖ Functional parity: ~40% of C++ capability
- ‚úÖ Code size reduction: 15-25% on typical Emscripten output
- ‚úÖ All 300+ existing tests pass
- ‚úÖ 150+ new tests added (6-8 per pass)

### Qualitative
- ‚úÖ Single-function optimization pipeline complete
- ‚úÖ Reusable CFG and dominance infrastructure in place
- ‚úÖ Arena-based tree manipulation proven (unblocks Tier 3+)

### Infrastructure Unlocked
- **LocalGraph**: Enables advanced local optimizations
- **ControlFlowGraph**: Foundation for inter-procedural analysis
- **DominanceTree**: Required for SSA construction and advanced passes
- **SSA form**: Unlocks Tier 4 data flow optimizations

---

## Next Steps After Tier 2

With Tier 2 complete:
- ‚úÖ Single-function optimizations work end-to-end
- ‚úÖ All foundational analyses implemented
- ‚úÖ Arena-based tree manipulation proven

**Natural progression**: Move to **Tier 3 (Expression & Instruction Optimization)**, focusing on `OptimizeInstructions` (the single highest-impact pass in Binaryen).

See `2.3-tier3-expression.md` for details.

# Missing or incomplete Passes after initial work done

Tier 2 is currently the most "dishonest" part of the Rust port documentation. While infrastructure like `ControlFlowGraph` and `DominanceTree` base classes have been implemented, the 24 passes listed above are almost entirely hollow. The "100% Pass Rate" reported in session summaries refers to the fact that these skeletal passes do not crash, but they lack the algorithmic depth required for actual optimization.

### Tier 2 Pass Maturity Matrix

| Rust Pass File | Equivalent C++ Implementation | Port % | Critical Gap / Missing Piece |
| :--- | :--- | :--- | :--- |
| `simplify_locals.rs` | [SimplifyLocals.cpp](../../../src/passes/SimplifyLocals.cpp) | **60%** | Basic sinking/teeing done; missing complex CFG-aware sinking and aggressive merging. |
| `coalesce_locals.rs` | [CoalesceLocals.cpp](../../../src/passes/CoalesceLocals.cpp) | **60%** | Implements basic interference coloring; missing copy coalescing and multi-value locals. |
| `untee.rs` | [Untee.cpp](../../../src/passes/Untee.cpp) | **90%** | **Functional**: Correctly utilizes the new Arena allocator to rewrite LocalTees. |
| `local_cse.rs` | [LocalCSE.cpp](../../../src/passes/LocalCSE.cpp) | **10%** | **Skeleton**: Defines the hashing infrastructure but lacks the actual recursive replacement logic. |
| `merge_blocks.rs` | [MergeBlocks.cpp](../../../src/passes/MergeBlocks.cpp) | **30%** | Only handles trivial "single-parent, single-child" merges; skips sequential block-chaining. |
| `dae.rs` / `dae_optimizing.rs` | [DAE.cpp](../../../src/passes/DAE.cpp) | **5%** | **Stub**: Identity transformations only; no actual parameter pruning logic. |
| `licm.rs` | [LICM.cpp](../../../src/passes/LICM.cpp) | **5%** | **Stub**: No loop-invariant analysis or pre-header hoisting implemented. |
| `rereloop.rs` | [ReReloop.cpp](../../../src/passes/ReReloop.cpp) | **5%** | **Stub**: No logic for irreducibility detection or node splitting. |
| `ssa.rs` / `ssa_nomerge.rs` | [SSA.cpp](../../../src/passes/SSA.cpp) | **5%** | **Stub**: Skeletons that do not perform Phi-node insertion or variable versioning. |
| `rse.rs` | [RedundantSetElimination.cpp](../../../src/passes/RedundantSetElimination.cpp) | **5%** | **Stub**: Missing the def-use graph logic needed to identify shadowed sets. |
| `pick_load_signs.rs` | [PickLoadSigns.cpp](../../../src/passes/PickLoadSigns.cpp) | **5%** | **Stub**: Does not analyze sign usage of loaded values. |
| `flatten.rs` | [Flatten.cpp](../../../src/passes/Flatten.cpp) | **5%** | **Stub**: No code to actual flatten nested expression trees. |
