# Team IR Plan — Phase 2 & 3 (Types & Basic IR)

Short summary:
- **Goal**: Implement the core WebAssembly type system (`Type`, `HeapType`, `Signature`) and the foundational Intermediate Representation (IR) nodes (`Expression`).
- **Context**: This builds upon the `binaryen-support` (Arena, Interner) delivered in Phase 1. This is the first phase where we implement actual compiler logic.
- **See also**: [Master Plan Phase 2](../vision/RUST_CONVERSION_PLAN.md#phase-2-type-system) & [Phase 3](../vision/RUST_CONVERSION_PLAN.md#phase-3-ir-core).

## 1. Objectives

1.  **Complete Type System**: Expand the skeletal `Type` enum to cover all WebAssembly types (including SIMD and GC). Implement `Signature` and `HeapType`.
2.  **Foundational IR**: Define the `Expression` enum and implement the first set of nodes (`Const`, `Block`, `LocalGet`).
3.  **Memory Model Integration**: Firmly establish how `Arena` (from Phase 1) integrates with IR nodes. This is a critical architectural decision.
4.  **FFI Interop**: Provide safe, stable FFI boundaries for Types and IR nodes to allow C++ to consume Rust-built IR.

## 2. Current Status

- **Existing Code**: `rust/binaryen-core` contains a matured `Type` enum with basic value and common reference types implemented (`I32`, `I64`, `F32`, `F64`, `V128`, `funcref`, `externref`, etc.), a basic `HeapType` implementation with core heap kinds, and a simple `Signature` struct.
- **Dependencies**: `binaryen-support` provides `Arena` and `StringInterner`, which are implemented and tested.
- **Progress / Gap**: `Signature` and `HeapType` have basic implementations, but **interning (TypeStore)**, FFI exposure for types, ordering/printing utilities, and canonicalization remain to be completed. The `Expression` enum and IR node implementations are not yet started and should be developed after `TypeStore` is stabilized.

## 3. Detailed Design

### 3.1 The Type System (`rust/binaryen-core/src/type.rs`)

The `Type` struct/enum is the vocabulary of the compiler. It must be small (`Copy`), efficient, and FFI-safe.

-   **Representation**:
    -   Likely a `u32` or a small struct wrapping a `u32` (matching C++ `wasm::Type` representation where possible for easy interop, or mapping efficiently).
    -   **Value Semantics**: `Type` should be `Copy`.
-   **Scope**:
    -   Basic: `i32`, `i64`, `f32`, `f64`, `v128`.
    -   References: `funcref`, `externref`, `anyref`, `eqref`, etc.
    -   Tuples/Multi-value: Needed for block types and function results.
-   **HeapType & Signature**:
    -   `HeapType`: Represents the structure of an object in the heap (structs, arrays, function signatures). Likely needs interning.
    -   `Signature`: `(params: Type, results: Type)`.

### 3.2 The IR (`rust/binaryen-core/src/expression.rs`)

This is the core data structure.

-   **Enum Structure**:
    ```rust
    pub enum Expression<'a> {
        Block(Block<'a>),
        Const(Literal),
        LocalGet(Index),
        // ...
    }
    ```
-   **Memory Management (Crucial)**:
    -   **Decision**: We will use **Arena Allocation** (`bumpalo` based, via `binaryen-support::Arena`).
    -   **Rationale**: Matches C++ Binaryen's performance profile (fast allocation, bulk deallocation). Avoids overhead of individual `Box` allocations.
    -   **Implication**: IR nodes will carry a lifetime `'a` tied to the Arena.
    -   **Reference**: `&'a Expression<'a>` or a wrapper `ExprRef<'a>`.

### 3.3 FFI Strategy

-   **Types**: `Type` should be `#[repr(C)]` or have a direct mapping to `binaryen_type_t`.
-   **IR Nodes**:
    -   **Opaque Handles**: C++ should not see Rust enums directly.
    -   **API**: `BinaryenBlockCreate(arena, ...)` returns a `BinaryenExpressionRef`.
    -   **Safety**: The FFI boundary must ensure that `ExprRef`s are not used after the `Arena` is disposed.

## 4. Implementation Roadmap

### Step 1: The Type System (High Priority)
-   [x] **Expand `Type`**: Add `V128`, `FuncRef`, `ExternRef`, etc.
-   [x] **Implement `Signature`**: Basic `Signature` type implemented (params: `Type`, results: `Type`).
-   [x] **Implement `HeapType`**: Basic `HeapType` implemented with core constants.
-   [x] **Implement `TypeStore` (interning)**: ✅ Added `rust/binaryen-core/src/type_store.rs` with global `RwLock<TypeStore>` singleton, signature interning with HashMap, and intern/lookup functions.
-   [x] **Add constructors that intern types**: ✅ Implemented `type_store::intern_signature()` and `lookup_signature()` with Type handle encoding (SIGNATURE_FLAG bit).
-   [x] **FFI wrappers for Types**: ✅ Added `rust/binaryen-ffi/src/type_ffi.rs` with `BinaryenTypeCreateSignature`, `BinaryenTypeGetParams`, `BinaryenTypeGetResults`, and basic type getters.
-   [ ] **Type utilities & printing**: ⚠️ Partial - Basic `Debug`/`Display` exist but don't query TypeStore for interned types. Need to enhance Display to show "(param i32) (result f64)" format.
-   [x] **Testing & Cross-language validation**: ✅ Added `test/rust_consumer/test_ffi_type_roundtrip.c` with C++ roundtrip test validating signature creation, interning, and param/result queries. Rust unit tests in type_ffi.rs (4 tests) and type_store.rs (4 tests) passing.
-   [ ] **Exit Criteria**: ⚠️ Nearly complete - TypeStore implemented and tested, FFI wrappers functional, cross-language tests passing. Remaining: Enhanced Display for interned types, property tests for concurrency, golden header update.

---

## Detailed Plan (expanded)
Below are concrete implementation steps, design choices, and short code examples to guide development and reviews.

1) Implement `TypeStore` (backend)
- File: `rust/binaryen-core/src/type_store.rs`
- Purpose: Intern complex definitions (Signatures, HeapTypes) and map them to compact IDs used by `Type` (u64).
- Concurrency: Start with a global `RwLock<TypeStore>` using `once_cell::sync::Lazy` for simplicity. Replace with `dashmap` or sharded maps if contention appears.

```rust
pub struct TypeStore {
    signatures: HashMap<(Type, Type), u32>,
    rev_signatures: HashMap<u32, Signature>,
}
static TYPE_STORE: Lazy<RwLock<TypeStore>> = Lazy::new(Default::default);
```

2) Type handle encoding
- Goal: Keep `Type` as a `Copy` handle while distinguishing basic vs interned types. Define a bit encoding where low values are basic types and a high bit denotes "interned signature" or "interned heap type". Keep layout compact and documented near `type.rs`.

```rust
// Example helpers (conceptual)
impl Type {
    pub fn is_interned_sig(self) -> bool { (self.0 & 0x8000_0000) != 0 }
}
```

3) Interning API and constructors
- Implement `TypeStore::intern_signature(params: Type, results: Type) -> Type` and `TypeStore::lookup_signature(ty: Type) -> Option<Signature>`.
- Provide ergonomic `Signature::intern(&[Type], &[Type]) -> Type` helpers that call into the global store and return a `Type` handle.

4) FFI: `binaryen-ffi/src/type_ffi.rs`
- Expose safe, minimal functions for C consumers:
  - `BinaryenTypeCreateSignature(params: Type, results: Type) -> Type`
  - `BinaryenTypeGetParams(ty: Type) -> Type`
  - `BinaryenTypeGetResults(ty: Type) -> Type`
- All functions are `#[no_mangle] pub extern "C"` and handle invalid inputs safely by returning `Type::NONE` or similar sentinel.

```rust
#[no_mangle]
pub extern "C" fn BinaryenTypeCreateSignature(params: Type, results: Type) -> Type {
    binaryen_core::type_store::intern_signature(params, results)
}
```

5) Printing, ordering & subtyping
- Implement `Display` for interned types by querying the store during formatting. Add canonicalization helpers used by the IR and passes.
- Add `proptest` rules that assert round-trip formatting/parsing and deterministic ordering.

6) Cross-language tests
- Add `test/rust_consumer/test_ffi_type_roundtrip.cpp` with C++ test that:
  1. Calls `BinaryenTypeCreateSignature(i32,i32)` to get a `Type` handle.
  2. Validates `BinaryenTypeGetParams` returns `i32`.
  3. Ensures repeated creation yields the same interned handle.
- Add Rust unit tests that ensure the same behavior under `TYPE_STORE` concurrency.

7) Execution order (small iterations)
- Implement core `TypeStore` and basic intern/lookup functions.
- Add `Signature::intern` and unit tests.
- Add simple FFI functions and the C++ round-trip test.
- Add Display/Debug and property tests.
- Iterate on concurrency (replace `RwLock` with a concurrent map if contention is observed).

### Notes & Rationale
- Keeping `Type` as a small `Copy` value simplifies IR node storage and FFI transfers.
- Interning keeps canonicalization and equality checks cheap and consistent across language boundaries.
- Global `TYPE_STORE` mirrors C++ Binaryen's global type context, easing comparisons and tests.

---

Proceed to Step 2 (IR work) only after these items are implemented and the cross-language tests are stable.

### Step 2: IR Skeleton & Arena Integration (Critical)
-   [ ] **Precondition**: Stabilize `TypeStore` and FFI type interop before starting IR node work; `Expression` relies on stable, interned `Type` handles.
-   [ ] **Define `Expression` Enum**: Create the enum with lifetime `'a` once types are stable.
-   [ ] **Arena Integration & Lifetimes**: Ensure `Arena` allocation strategy and lifetimes are compatible with interned `Type` handles; add tests that validate arena lifetime invariants across FFI boundaries.
-   [ ] **Proof of Concept**: Implement `Const` node after type store is stable. Allocate it in an Arena and assert validity.

### Step 3: Basic Nodes
-   [ ] **Implement `Block`**: Requires `&'a [ExprRef<'a>]` (slice of references).
-   [ ] **Implement `LocalGet`**: Simple leaf node.
-   [ ] **FFI Wrappers**: Expose these creators to C++.
-   [ ] **Update Cbindgen**: Ensure `cbindgen.toml` picks up new `#[repr(C)]` types and functions.

## 5. Testing Strategy

-   **Unit Tests**: Rust-side tests for type properties and IR construction.
-   **Property Tests**: `proptest` for Type serialization round-trips.
-   **FFI Smoke Tests**:
    -   Create an Arena in C++.
    -   Call Rust to create a `Block` with some `Const`s.
    -   Verify the structure is correct (via a debug print or inspection API).
-   **Sanitizers**: Run ASAN tests to ensure Arena usage across FFI doesn't leak or use-after-free.

## 6. Risks & Mitigations

-   **Risk**: Arena lifetime complexity in Rust (`self-referential` structs if Module owns Arena and IR).
    -   **Mitigation**: Keep `Arena` ownership separate from `Module` initially, or use a "Context" object that owns the Arena.
-   **Risk**: FFI overhead for fine-grained IR construction.
    -   **Mitigation**: Batch operations where possible, or accept that the C++ -> Rust transition layer has some cost (but Rust -> Rust is fast).

---
*This document serves as the architectural guide for Team IR.*
