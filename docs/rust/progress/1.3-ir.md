# Team IR Plan â€” Phase 2 & 3 (Types & Basic IR)

Short summary:
- **Goal**: Implement the core WebAssembly type system (`Type`, `HeapType`, `Signature`) and the foundational Intermediate Representation (IR) nodes (`Expression`).
- **Context**: This builds upon the `binaryen-support` (Arena, Interner) delivered in Phase 1. This is the first phase where we implement actual compiler logic.
- **See also**: [Master Plan Phase 2](../vision/RUST_CONVERSION_PLAN.md#phase-2-type-system) & [Phase 3](../vision/RUST_CONVERSION_PLAN.md#phase-3-ir-core).

## 1. Objectives

1.  **Complete Type System**: Expand the skeletal `Type` enum to cover all WebAssembly types (including SIMD and GC). Implement `Signature` and `HeapType`.
2.  **Foundational IR**: Define the `Expression` enum and implement the first set of nodes (`Const`, `Block`, `LocalGet`).
3.  **Memory Model Integration**: Firmly establish how `Arena` (from Phase 1) integrates with IR nodes. This is a critical architectural decision.
4.  **FFI Interop**: Provide safe, stable FFI boundaries for Types and IR nodes to allow C++ to consume Rust-built IR.

## 2. Current Status

- **Existing Code**: `rust/binaryen-core` contains a skeletal `Type` enum (`I32`, `I64`, `F32`, `F64`, `None`).
- **Dependencies**: `binaryen-support` provides `Arena` and `StringInterner`, which are implemented and tested.
- **Gap**: The `Type` system is missing reference types, vector types, and GC types. `Expression` and `HeapType` are unimplemented.

## 3. Detailed Design

### 3.1 The Type System (`rust/binaryen-core/src/type.rs`)

The `Type` struct/enum is the vocabulary of the compiler. It must be small (`Copy`), efficient, and FFI-safe.

-   **Representation**:
    -   Likely a `u32` or a small struct wrapping a `u32` (matching C++ `wasm::Type` representation where possible for easy interop, or mapping efficiently).
    -   **Value Semantics**: `Type` should be `Copy`.
-   **Scope**:
    -   Basic: `i32`, `i64`, `f32`, `f64`, `v128`.
    -   References: `funcref`, `externref`, `anyref`, `eqref`, etc.
    -   Tuples/Multi-value: Needed for block types and function results.
-   **HeapType & Signature**:
    -   `HeapType`: Represents the structure of an object in the heap (structs, arrays, function signatures). Likely needs interning.
    -   `Signature`: `(params: Type, results: Type)`.

### 3.2 The IR (`rust/binaryen-core/src/expression.rs`)

This is the core data structure.

-   **Enum Structure**:
    ```rust
    pub enum Expression<'a> {
        Block(Block<'a>),
        Const(Literal),
        LocalGet(Index),
        // ...
    }
    ```
-   **Memory Management (Crucial)**:
    -   **Decision**: We will use **Arena Allocation** (`bumpalo` based, via `binaryen-support::Arena`).
    -   **Rationale**: Matches C++ Binaryen's performance profile (fast allocation, bulk deallocation). Avoids overhead of individual `Box` allocations.
    -   **Implication**: IR nodes will carry a lifetime `'a` tied to the Arena.
    -   **Reference**: `&'a Expression<'a>` or a wrapper `ExprRef<'a>`.

### 3.3 FFI Strategy

-   **Types**: `Type` should be `#[repr(C)]` or have a direct mapping to `binaryen_type_t`.
-   **IR Nodes**:
    -   **Opaque Handles**: C++ should not see Rust enums directly.
    -   **API**: `BinaryenBlockCreate(arena, ...)` returns a `BinaryenExpressionRef`.
    -   **Safety**: The FFI boundary must ensure that `ExprRef`s are not used after the `Arena` is disposed.

## 4. Implementation Roadmap

### Step 1: The Type System (High Priority)
-   [ ] **Expand `Type`**: Add `V128`, `FuncRef`, `ExternRef`, etc.
-   [ ] **Implement `Signature`**: Add support for parameter and result types.
-   [ ] **Implement `HeapType`**: Basic structure for GC types.
-   [ ] **Implement Ordering**: Implement `PartialOrd`/`Ord` for types to support canonicalization.
-   [ ] **Tests**: Unit tests for equality, printing, and serialization.

### Step 2: IR Skeleton & Arena Integration (Critical)
-   [ ] **Define `Expression` Enum**: Create the enum with lifetime `'a`.
-   [ ] **Arena Integration**: Create helper traits/structs to allocate Expressions in the `Arena`.
-   [ ] **Proof of Concept**: Implement `Const` node. Allocate it in an Arena. Assert validity.

### Step 3: Basic Nodes
-   [ ] **Implement `Block`**: Requires `&'a [ExprRef<'a>]` (slice of references).
-   [ ] **Implement `LocalGet`**: Simple leaf node.
-   [ ] **FFI Wrappers**: Expose these creators to C++.
-   [ ] **Update Cbindgen**: Ensure `cbindgen.toml` picks up new `#[repr(C)]` types and functions.

## 5. Testing Strategy

-   **Unit Tests**: Rust-side tests for type properties and IR construction.
-   **Property Tests**: `proptest` for Type serialization round-trips.
-   **FFI Smoke Tests**:
    -   Create an Arena in C++.
    -   Call Rust to create a `Block` with some `Const`s.
    -   Verify the structure is correct (via a debug print or inspection API).
-   **Sanitizers**: Run ASAN tests to ensure Arena usage across FFI doesn't leak or use-after-free.

## 6. Risks & Mitigations

-   **Risk**: Arena lifetime complexity in Rust (`self-referential` structs if Module owns Arena and IR).
    -   **Mitigation**: Keep `Arena` ownership separate from `Module` initially, or use a "Context" object that owns the Arena.
-   **Risk**: FFI overhead for fine-grained IR construction.
    -   **Mitigation**: Batch operations where possible, or accept that the C++ -> Rust transition layer has some cost (but Rust -> Rust is fast).

---
*This document serves as the architectural guide for Team IR.*
