# Tier 3: Expression & Instruction Optimization
**Status**: � In Progress | **Passes**: 18 | **Estimated Effort**: 3–5 weeks | **Target**: Week 10-14

---

## Overview

Tier 3 contains the **highest-impact optimizations** in Binaryen. The centerpiece is `OptimizeInstructions`, which alone accounts for 30-40% of C++'s optimization power. These passes focus on expression-level transformations using pattern matching and constant folding.

**Critical Success Factor**: Building a reusable **pattern matching framework** to avoid code duplication across algebraic simplification passes.

---

## Group 3A: Constant Folding & Arithmetic

**Passes**: 6 | **Effort**: 15-17 days

### Pass List
1. **precompute** — Compile-time evaluation of pure operations
2. **precompute-propagate** — Precompute + propagate through locals
3. **const-hoisting** — Move constants to better positions  
4. **optimize-casts** — Remove redundant/no-op casts
5. **denan** — Normalize NaN values
6. **avoid-reinterprets** — Safe type casting (also in Tier 2C)

### Shared Infrastructure: Expression Evaluator (3 days)

```rust
// rust/binaryen-ir/src/analysis/evaluator.rs

/// Compile-time expression evaluator
pub struct Evaluator<'a> {
    arena: &'a Bump,
    /// Known constant values for globals/locals
    constants: HashMap<GlobalId, Literal>,
}

impl<'a> Evaluator<'a> {
    /// Evaluate expression to constant if possible
    pub fn eval(&self, expr: ExprRef) -> Option<Literal> {
        match expr.kind {
            ExpressionKind::Const(lit) => Some(lit),
            ExpressionKind::Binary { op, left, right } => {
                let l = self.eval(left)?;
                let r = self.eval(right)?;
                self.eval_binary(op, l, r)
            }
            ExpressionKind::Unary { op, value } => {
                let v = self.eval(value)?;
                self.eval_unary(op, v)
            }
            // ... handle other pure operations
            _ => None,
        }
    }
    
    fn eval_binary(&self, op: BinaryOp, l: Literal, r: Literal) -> Option<Literal> {
        // Implement all binary operations
        match op {
            BinaryOp::AddInt32 => Some(Literal::I32(l.get_i32() + r.get_i32())),
            BinaryOp::MulInt32 => Some(Literal::I32(l.get_i32() * r.get_i32())),
            // ... all other ops
        }
    }
}
```

### Pass: precompute (4 days)

**Purpose**: Fold all compile-time evaluatable expressions

**Algorithm**:
1. Walk expression tree
2. For each node, try to evaluate using Evaluator
3. If successful, replace with const

**Example**:
```wasm
;; Before: (i32.add (i32.const 1) (i32.mul (i32.const 2) (i32.const 3)))
;; After:  (i32.const 7)
```

**C++ Reference**: `src/passes/Precompute.cpp` (~400 lines)

---

### Pass: const-hoisting (3 days)

**Purpose**: Move repeated constants to locals to reduce code size

**Algorithm**:
1. Count occurrences of each constant
2. If constant used >N times, introduce local
3. Replace all uses with local.get

**Example**:
```wasm
;; Before:
(i32.add (i32.const 42) (i32.mul (i32.const 42) (i32.const 42)))

;; After:
(local $const_42 i32)
(local.set $const_42 (i32.const 42))
(i32.add (local.get $const_42) (i32.mul (local.get $const_42) (local.get $const_42)))
```

**C++ Reference**: `src/passes/ConstHoisting.cpp` (~250 lines)

---

## Group 3B: Algebraic & Strength Reduction

**Passes**: 7 | **Effort**: 28-35 days

### Pass List
1. **optimize-instructions** ⚠️ **CRITICAL** (5,825 lines in C++!)
2. **code-folding** (✅ partially done) — Common subexpression elimination  
3. **simplify-identity** (✅ done) — x+0, x*1, etc.
4. **intrinsic-lowering** — Optimize compiler intrinsics
5. **licm** (also in Tier 2B) — Loop-invariant code motion
6. **alignment-lowering** — Optimize alignment operations
7. **generate-global-effects** — Whole-program effect analysis

### Shared Infrastructure: Pattern Matching Framework (4 days)

```rust
// rust/binaryen-ir/src/analysis/patterns.rs

/// Pattern matching DSL for simplification rules
pub enum Pattern {
    /// Match any expression
    Any,
    /// Match specific constant
    Const(Literal),
    /// Match any constant
    AnyConst,
    /// Match variable (captured in environment)
    Var(&'static str),
    /// Match specific operation
    Binary { op: BinaryOp, left: Box<Pattern>, right: Box<Pattern> },
    Unary { op: UnaryOp, operand: Box<Pattern> },
}

pub struct Rule {
    pub pattern: Pattern,
    pub replacement: fn(&Env) -> ExprRef,
    pub condition: Option<fn(&Env) -> bool>,
}

/// Apply simplification rules to expression
pub struct PatternMatcher {
    rules: Vec<Rule>,
}

impl PatternMatcher {
    pub fn new() -> Self {
        let mut rules = vec![];
        
        // x + 0 -> x
        rules.push(Rule {
            pattern: Pattern::Binary {
                op: BinaryOp::AddInt32,
                left: Box::new(Pattern::Var("x")),
                right: Box::new(Pattern::Const(Literal::I32(0))),
            },
            replacement: |env| env.get("x"),
            condition: None,
        });
        
        // 0 + x -> x
        rules.push(Rule {
            pattern: Pattern::Binary {
                op: BinaryOp::AddInt32,
                left: Box::new(Pattern::Const(Literal::I32(0))),
                right: Box::new(Pattern::Var("x")),
            },
            replacement: |env| env.get("x"),
            condition: None,
        });
        
        // Add hundreds more rules...
        
        Self { rules }
    }
    
    pub fn simplify(&self, expr: ExprRef) -> Option<ExprRef> {
        for rule in &self.rules {
            if let Some(env) = self.match_pattern(&rule.pattern, expr) {
                if rule.condition.map(|c| c(&env)).unwrap_or(true) {
                    return Some((rule.replacement)(&env));
                }
            }
        }
        None
    }
}
```

### Pass: optimize-instructions (10-15 days, CRITICAL)

**Purpose**: The Swiss Army knife of optimization - algebraic simplification, strength reduction, peephole opts

**Categories of patterns** (break into ~5 modules):

1. **Constant folding patterns** (3 days):
   - Fold constants in all operations
   - Handle overflow, division by zero
   - NaN and infinity handling

2. **Algebraic identities** (4 days):
   - x + 0 → x, x * 1 → x, x - 0 → x
   - x * 0 → 0, x & 0 → 0, x | 0 → x
   - x & x → x, x | x → x, x ^ x → 0
   - !(!)x → x (double negation)
   - Commutative operator normalization

3. **Strength reduction** (3 days):
   - x * 2^n → x << n
   - x / 2^n → x >> n (for unsigned)
   - x % 2^n → x & (2^n - 1)
   - Expensive operations → cheaper equivalents

4. **Comparison optimizations** (3 days):
   - (x < 10) & (x < 20) → x < 10
   - (x == 0) | (x == 1) → x <= 1 (when values known small)
   - Constant comparison folding
   - Redundant comparison elimination

5. **Load/store forwarding** (2 days):
   - Eliminate redundant memory operations
   - Forward stored values to subsequent loads
   - Merge adjacent stores

**C++ Reference**: `src/passes/OptimizeInstructions.cpp` (5,825 lines!)

**Implementation Strategy**:
- Start with high-frequency patterns (algebraic identities)
- Add categories incrementally
- Extensive testing for each category
- Reuse PatternMatcher framework

**Testing**:
```rust
#[test]
fn test_optimize_add_zero() {
    // x + 0 -> x
    let bump = Bump::new();
    let mut builder = IrBuilder::new(&bump);
    
    let x = builder.local_get(0);
    let zero = builder.const_i32(0);
    let add = builder.binary(BinaryOp::AddInt32, x, zero);
    
    let mut pass = OptimizeInstructions::new();
    let result = pass.simplify(add);
    
    assert_eq!(result, x);  // Should reduce to just x
}
```

---

## Group 3C: Type Narrowing & Casting

**Passes**: 5 | **Effort**: 10-20 days

### Pass List
1. **local-subtyping** (also in Tier 2A) — Refine local types
2. **global-refining** — Narrow global types
3. **type-refining** — Infer tighter type bounds
4. **optimize-casts** (also in 3A) — Remove unnecessary casts
5. **pick-load-signs** (also in Tier 2C) — Infer load signedness

### Implementation Notes

These passes share type inference infrastructure:

```rust
// rust/binaryen-ir/src/analysis/type_inference.rs

pub struct TypeInference {
    /// Inferred types (more specific than declared)
    inferred_locals: HashMap<LocalId, Type>,
    inferred_globals: HashMap<GlobalId, Type>,
}

impl TypeInference {
    /// Analyze function and infer tighter types
    pub fn analyze(func: &Function) -> Self {
        // Track all assignments to each local/global
        // Compute least upper bound (LUB) of all types
        // If LUB more specific than declared, record it
    }
}
```

---

## Tier 3 Timeline

**Week 10**: Infrastructure + precompute
- Day 1-3: Build Evaluator
- Day 4-5: Implement precompute + precompute-propagate

**Week 11**: Pattern matching + first patterns
- Day 1-4: Build PatternMatcher framework
- Day 5: Start OptimizeInstructions (constant folding)

**Week 12-13**: OptimizeInstructions categories
- Week 12: Algebraic identities + strength reduction
- Week 13: Comparisons + load/store forwarding

**Week 14**: Group 3A/3C completion
- Day 1-2: const-hoisting, optimize-casts
- Day 3-5: Type narrowing passes (3C)

---

## Success Criteria

### Quantitative
- ✅ 18 passes implemented (30 → 48 total)
- ✅ Functional parity: ~55% of C++ capability  
- ✅ **Code size reduction**: 30-40% (OptimizeInstructions impact)
- ✅ Pattern matcher: 100+ simplification rules

### Qualitative
- ✅ OptimizeInstructions provides majority of optimization value
- ✅ Reusable pattern matching prevents code duplication
- ✅ Expression evaluator enables advanced constant folding

### Impact
**Most important tier for users**: After Tier 3, the Rust port delivers the majority of optimization benefits visible in typical use cases.

---

## Next Steps

With Tier 3 complete, you have achieved **majority functional parity** with C++ for common use cases.

**Natural progression**: Move to **Tier 4 (Advanced Analysis & Transforms)** for inlining, SSA-based optimizations, and whole-module analysis.

See `2.4-tier4-advanced.md` for details.

# Missing or incomplete Passes after initial work done

Tier 3 represents the "Performance Core" of Binaryen, and while the infrastructure for pattern matching and constant evaluation is present, the actual coverage is in its infancy. `OptimizeInstructions`—the most critical pass in the engine—currently implements fewer than 20 rules, compared to the thousands of specialized patterns in the C++ version. The "100% Pass Rate" is a validation of the `PatternMatcher` engine's safety, not the completeness of its optimization rules.

### Tier 3 Pass Maturity Matrix

| Rust Pass File | Equivalent C++ Implementation | Port % | Critical Gap / Missing Piece |
| :--- | :--- | :--- | :--- |
| `optimize_instructions.rs` | [OptimizeInstructions.cpp](../../../src/passes/OptimizeInstructions.cpp) | **100% (Algebraic Identities), 10% (Overall)** | **Partial**: All basic algebraic identities (commutative normalization, zero/one identities) are implemented for Int32, Int64, Float32, and Float64. Strength reduction (x * 2^n, x / 2^n, x % 2^n) and basic unsigned comparison optimizations with zero are implemented for Int32 and Int64. Still lacks ~500+ rules for bitwise, floating point, and SIMD. |
| `precompute.rs` | [Precompute.cpp](../../../src/passes/Precompute.cpp) | **35%** | **Partial**: Folds I32 and I64 arithmetic; missing cross-block local propagation and GC type folding. |
| `precompute_propagate.rs` | [Precompute.cpp](../../../src/passes/Precompute.cpp) | **20%** | **Partial**: Propagates constants through locals in straight-line code; missing dataflow analysis for control flow merges. |
| `simplify_identity.rs` | [SimplifyIdentity.cpp](../../../src/passes/SimplifyIdentity.cpp) | **40%** | **Partial**: Handles integer identities (x+0, x*1, x&-1) and `eqz(eqz(eqz(x)))` folding; misses float identities (mostly covered in `OptimizeInstructions`). |
| `const_hoisting.rs` | [ConstHoisting.cpp](../../../src/passes/ConstHoisting.cpp) | **45%** | **Foundational**: Successfully counts occurrences and hoists >N constants to locals; lacks a cost model for LEB128 overhead and multi-value type support. |
| `local_cse.rs` | [LocalCSE.cpp](../../../src/passes/LocalCSE.cpp) | **15%** | **Initial**: Basic structural equality for expressions using key-based mapping; restricted to simple nodes (Const, LocalGet, Binary, Unary). |
| `simplify.rs` | [Simplify.cpp](../../../src/passes/Simplify.cpp) | **45%** | **Partial**: Handles `x-x=0`, `x^x=0`, and `if`/`select` with constant conditions; missing 90% of Binaryen's "heavy lifting" logic. |
| `local_subtyping.rs` | [LocalSubtyping.cpp](../../../src/passes/LocalSubtyping.cpp) | **15%** | **Partial**: Scans assignments and computes LUB for local variables; missing refined analysis of control-flow paths. |
| `optimize_casts.rs` | [OptimizeCasts.cpp](../../../src/passes/OptimizeCasts.cpp) | **10%** | **Initial**: Removes simple `wrap(extend(x))` chains; does not yet handle more complex cast optimizations. |
| `avoid_reinterprets.rs` | [AvoidReinterprets.cpp](../../../src/passes/AvoidReinterprets.cpp) | **5%** | **Stub**: Basic pass structure with no active logic. |
| `licm.rs` | [LICM.cpp](../../../src/passes/LICM.cpp) | **5%** | **Stub**: Basic pass structure; no logic for identifying or hoisting loop-invariant code. |
| `type_refining.rs` | [TypeRefining.cpp](../../../src/passes/TypeRefining.cpp) | **5%** | **Stub**: No logic for inferring tighter bounds for GC types or multi-value results. |
| `global_refining.rs` | [GlobalRefining.cpp](../../../src/passes/GlobalRefining.cpp) | **10%** | **Infrastructure**: Initial global access scanning; lacks the whole-module usage analysis to safely tighten types. |
| `pick_load_signs.rs` | [PickLoadSigns.cpp](../../../src/passes/PickLoadSigns.cpp) | **5%** | **Stub**: Basic pass structure; missing data-flow analysis required to choose optimal load signedness. |

## Tier 3 Outstanding Blocks Summary

The current Tier 3 implementation has solid infrastructure (Pattern Matcher, Evaluator) but lacks breadth in coverage.

1.  **OptimizeInstructions Rules (Gap: ~500+ rules)**: The centerpiece requires massive expansion. Priority should be given to bitwise patterns (e.g., `(x << k) >> k`) and floating-point specific optimizations that Binaryen C++ excels at.
2.  **Advanced Constant Propagation**: `Precompute` and `PrecomputePropagate` need to move beyond straight-line code by implementing a robust dataflow analysis framework (building on current visitors).
3.  **Type System Maturity**: Passes like `TypeRefining` and `GlobalRefining` are blocked on more comprehensive GC type support in the Rust IR.
4.  **Floating Point & SIMD**: Coverage across all expression-level passes for Float32/64 and SIMD types is significantly lower than for integers.
5.  **Control Flow Awareness**: Most Tier 3 passes are "shallow" (looking at single expressions or blocks). They need deeper understanding of loops and branch targets to achieve parity.

