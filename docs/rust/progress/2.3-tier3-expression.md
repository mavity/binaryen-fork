# Tier 3: Expression & Instruction Optimization
**Status**: üìã Planned | **Passes**: 18 | **Estimated Effort**: 3‚Äì5 weeks | **Target**: Week 10-14

---

## Overview

Tier 3 contains the **highest-impact optimizations** in Binaryen. The centerpiece is `OptimizeInstructions`, which alone accounts for 30-40% of C++'s optimization power. These passes focus on expression-level transformations using pattern matching and constant folding.

**Critical Success Factor**: Building a reusable **pattern matching framework** to avoid code duplication across algebraic simplification passes.

---

## Group 3A: Constant Folding & Arithmetic

**Passes**: 6 | **Effort**: 15-17 days

### Pass List
1. **precompute** ‚Äî Compile-time evaluation of pure operations
2. **precompute-propagate** ‚Äî Precompute + propagate through locals
3. **const-hoisting** ‚Äî Move constants to better positions  
4. **optimize-casts** ‚Äî Remove redundant/no-op casts
5. **denan** ‚Äî Normalize NaN values
6. **avoid-reinterprets** ‚Äî Safe type casting (also in Tier 2C)

### Shared Infrastructure: Expression Evaluator (3 days)

```rust
// rust/binaryen-ir/src/analysis/evaluator.rs

/// Compile-time expression evaluator
pub struct Evaluator<'a> {
    arena: &'a Bump,
    /// Known constant values for globals/locals
    constants: HashMap<GlobalId, Literal>,
}

impl<'a> Evaluator<'a> {
    /// Evaluate expression to constant if possible
    pub fn eval(&self, expr: ExprRef) -> Option<Literal> {
        match expr.kind {
            ExpressionKind::Const(lit) => Some(lit),
            ExpressionKind::Binary { op, left, right } => {
                let l = self.eval(left)?;
                let r = self.eval(right)?;
                self.eval_binary(op, l, r)
            }
            ExpressionKind::Unary { op, value } => {
                let v = self.eval(value)?;
                self.eval_unary(op, v)
            }
            // ... handle other pure operations
            _ => None,
        }
    }
    
    fn eval_binary(&self, op: BinaryOp, l: Literal, r: Literal) -> Option<Literal> {
        // Implement all binary operations
        match op {
            BinaryOp::AddInt32 => Some(Literal::I32(l.get_i32() + r.get_i32())),
            BinaryOp::MulInt32 => Some(Literal::I32(l.get_i32() * r.get_i32())),
            // ... all other ops
        }
    }
}
```

### Pass: precompute (4 days)

**Purpose**: Fold all compile-time evaluatable expressions

**Algorithm**:
1. Walk expression tree
2. For each node, try to evaluate using Evaluator
3. If successful, replace with const

**Example**:
```wasm
;; Before: (i32.add (i32.const 1) (i32.mul (i32.const 2) (i32.const 3)))
;; After:  (i32.const 7)
```

**C++ Reference**: `src/passes/Precompute.cpp` (~400 lines)

---

### Pass: const-hoisting (3 days)

**Purpose**: Move repeated constants to locals to reduce code size

**Algorithm**:
1. Count occurrences of each constant
2. If constant used >N times, introduce local
3. Replace all uses with local.get

**Example**:
```wasm
;; Before:
(i32.add (i32.const 42) (i32.mul (i32.const 42) (i32.const 42)))

;; After:
(local $const_42 i32)
(local.set $const_42 (i32.const 42))
(i32.add (local.get $const_42) (i32.mul (local.get $const_42) (local.get $const_42)))
```

**C++ Reference**: `src/passes/ConstHoisting.cpp` (~250 lines)

---

## Group 3B: Algebraic & Strength Reduction

**Passes**: 7 | **Effort**: 28-35 days

### Pass List
1. **optimize-instructions** ‚ö†Ô∏è **CRITICAL** (5,825 lines in C++!)
2. **code-folding** (‚úÖ partially done) ‚Äî Common subexpression elimination  
3. **simplify-identity** (‚úÖ done) ‚Äî x+0, x*1, etc.
4. **intrinsic-lowering** ‚Äî Optimize compiler intrinsics
5. **licm** (also in Tier 2B) ‚Äî Loop-invariant code motion
6. **alignment-lowering** ‚Äî Optimize alignment operations
7. **generate-global-effects** ‚Äî Whole-program effect analysis

### Shared Infrastructure: Pattern Matching Framework (4 days)

```rust
// rust/binaryen-ir/src/analysis/patterns.rs

/// Pattern matching DSL for simplification rules
pub enum Pattern {
    /// Match any expression
    Any,
    /// Match specific constant
    Const(Literal),
    /// Match any constant
    AnyConst,
    /// Match variable (captured in environment)
    Var(&'static str),
    /// Match specific operation
    Binary { op: BinaryOp, left: Box<Pattern>, right: Box<Pattern> },
    Unary { op: UnaryOp, operand: Box<Pattern> },
}

pub struct Rule {
    pub pattern: Pattern,
    pub replacement: fn(&Env) -> ExprRef,
    pub condition: Option<fn(&Env) -> bool>,
}

/// Apply simplification rules to expression
pub struct PatternMatcher {
    rules: Vec<Rule>,
}

impl PatternMatcher {
    pub fn new() -> Self {
        let mut rules = vec![];
        
        // x + 0 -> x
        rules.push(Rule {
            pattern: Pattern::Binary {
                op: BinaryOp::AddInt32,
                left: Box::new(Pattern::Var("x")),
                right: Box::new(Pattern::Const(Literal::I32(0))),
            },
            replacement: |env| env.get("x"),
            condition: None,
        });
        
        // 0 + x -> x
        rules.push(Rule {
            pattern: Pattern::Binary {
                op: BinaryOp::AddInt32,
                left: Box::new(Pattern::Const(Literal::I32(0))),
                right: Box::new(Pattern::Var("x")),
            },
            replacement: |env| env.get("x"),
            condition: None,
        });
        
        // Add hundreds more rules...
        
        Self { rules }
    }
    
    pub fn simplify(&self, expr: ExprRef) -> Option<ExprRef> {
        for rule in &self.rules {
            if let Some(env) = self.match_pattern(&rule.pattern, expr) {
                if rule.condition.map(|c| c(&env)).unwrap_or(true) {
                    return Some((rule.replacement)(&env));
                }
            }
        }
        None
    }
}
```

### Pass: optimize-instructions (10-15 days, CRITICAL)

**Purpose**: The Swiss Army knife of optimization - algebraic simplification, strength reduction, peephole opts

**Categories of patterns** (break into ~5 modules):

1. **Constant folding patterns** (3 days):
   - Fold constants in all operations
   - Handle overflow, division by zero
   - NaN and infinity handling

2. **Algebraic identities** (4 days):
   - x + 0 ‚Üí x, x * 1 ‚Üí x, x - 0 ‚Üí x
   - x * 0 ‚Üí 0, x & 0 ‚Üí 0, x | 0 ‚Üí x
   - x & x ‚Üí x, x | x ‚Üí x, x ^ x ‚Üí 0
   - !(!)x ‚Üí x (double negation)
   - Commutative operator normalization

3. **Strength reduction** (3 days):
   - x * 2^n ‚Üí x << n
   - x / 2^n ‚Üí x >> n (for unsigned)
   - x % 2^n ‚Üí x & (2^n - 1)
   - Expensive operations ‚Üí cheaper equivalents

4. **Comparison optimizations** (3 days):
   - (x < 10) & (x < 20) ‚Üí x < 10
   - (x == 0) | (x == 1) ‚Üí x <= 1 (when values known small)
   - Constant comparison folding
   - Redundant comparison elimination

5. **Load/store forwarding** (2 days):
   - Eliminate redundant memory operations
   - Forward stored values to subsequent loads
   - Merge adjacent stores

**C++ Reference**: `src/passes/OptimizeInstructions.cpp` (5,825 lines!)

**Implementation Strategy**:
- Start with high-frequency patterns (algebraic identities)
- Add categories incrementally
- Extensive testing for each category
- Reuse PatternMatcher framework

**Testing**:
```rust
#[test]
fn test_optimize_add_zero() {
    // x + 0 -> x
    let bump = Bump::new();
    let mut builder = IrBuilder::new(&bump);
    
    let x = builder.local_get(0);
    let zero = builder.const_i32(0);
    let add = builder.binary(BinaryOp::AddInt32, x, zero);
    
    let mut pass = OptimizeInstructions::new();
    let result = pass.simplify(add);
    
    assert_eq!(result, x);  // Should reduce to just x
}
```

---

## Group 3C: Type Narrowing & Casting

**Passes**: 5 | **Effort**: 10-20 days

### Pass List
1. **local-subtyping** (also in Tier 2A) ‚Äî Refine local types
2. **global-refining** ‚Äî Narrow global types
3. **type-refining** ‚Äî Infer tighter type bounds
4. **optimize-casts** (also in 3A) ‚Äî Remove unnecessary casts
5. **pick-load-signs** (also in Tier 2C) ‚Äî Infer load signedness

### Implementation Notes

These passes share type inference infrastructure:

```rust
// rust/binaryen-ir/src/analysis/type_inference.rs

pub struct TypeInference {
    /// Inferred types (more specific than declared)
    inferred_locals: HashMap<LocalId, Type>,
    inferred_globals: HashMap<GlobalId, Type>,
}

impl TypeInference {
    /// Analyze function and infer tighter types
    pub fn analyze(func: &Function) -> Self {
        // Track all assignments to each local/global
        // Compute least upper bound (LUB) of all types
        // If LUB more specific than declared, record it
    }
}
```

---

## Tier 3 Timeline

**Week 10**: Infrastructure + precompute
- Day 1-3: Build Evaluator
- Day 4-5: Implement precompute + precompute-propagate

**Week 11**: Pattern matching + first patterns
- Day 1-4: Build PatternMatcher framework
- Day 5: Start OptimizeInstructions (constant folding)

**Week 12-13**: OptimizeInstructions categories
- Week 12: Algebraic identities + strength reduction
- Week 13: Comparisons + load/store forwarding

**Week 14**: Group 3A/3C completion
- Day 1-2: const-hoisting, optimize-casts
- Day 3-5: Type narrowing passes (3C)

---

## Success Criteria

### Quantitative
- ‚úÖ 18 passes implemented (30 ‚Üí 48 total)
- ‚úÖ Functional parity: ~55% of C++ capability  
- ‚úÖ **Code size reduction**: 30-40% (OptimizeInstructions impact)
- ‚úÖ Pattern matcher: 100+ simplification rules

### Qualitative
- ‚úÖ OptimizeInstructions provides majority of optimization value
- ‚úÖ Reusable pattern matching prevents code duplication
- ‚úÖ Expression evaluator enables advanced constant folding

### Impact
**Most important tier for users**: After Tier 3, the Rust port delivers the majority of optimization benefits visible in typical use cases.

---

## Next Steps

With Tier 3 complete, you have achieved **majority functional parity** with C++ for common use cases.

**Natural progression**: Move to **Tier 4 (Advanced Analysis & Transforms)** for inlining, SSA-based optimizations, and whole-module analysis.

See `2.4-tier4-advanced.md` for details.

# Missing or incomplete Passes after initial work done

Tier 3 represents the "Performance Core" of Binaryen, and while the infrastructure for pattern matching and constant evaluation is present, the actual coverage is in its infancy. `OptimizeInstructions`‚Äîthe most critical pass in the engine‚Äîcurrently implements fewer than 20 rules, compared to the thousands of specialized patterns in the C++ version. The "100% Pass Rate" is a validation of the `PatternMatcher` engine's safety, not the completeness of its optimization rules.

### Tier 3 Pass Maturity Matrix

| Rust Pass File | Equivalent C++ Implementation | Port % | Critical Gap / Missing Piece |
| :--- | :--- | :--- | :--- |
| `optimize_instructions.rs` | [OptimizeInstructions.cpp](../../../src/passes/OptimizeInstructions.cpp) | **5%** | **Skeleton**: Validates the `PatternMatcher` engine but lacks ~300+ rules for bitwise, floating point, and SIMD. |
| `precompute.rs` | [Precompute.cpp](../../../src/passes/Precompute.cpp) | **30%** | **Partial**: Correctly folds simple `i32` arithmetic; missing cross-block local propagation and GC type folding. |
| `simplify_identity.rs` | [SimplifyIdentity.cpp](../../../src/passes/SimplifyIdentity.cpp) | **30%** | **Incomplete**: Rudimentary (x+0, x*1) identities for integers; misses float identities and commutativity checks. |
| `const_hoisting.rs` | [ConstHoisting.cpp](../../../src/passes/ConstHoisting.cpp) | **40%** | **Foundational**: Tracks constant frequency correctly but lacks a sophisticated cost model for LEB128 overhead. |
| `optimize_casts.rs` | [OptimizeCasts.cpp](../../../src/passes/OptimizeCasts.cpp) | **5%** | **Stub**: Identity transformation; does not yet identify redundant wrap/extend chains. |
| `type_refining.rs` | [TypeRefining.cpp](../../../src/passes/TypeRefining.cpp) | **5%** | **Stub**: No logic for inferring tighter bounds for GC types or multi-value results. |
| `global_refining.rs` | [GlobalRefining.cpp](../../../src/passes/GlobalRefining.cpp) | **10%** | **Infrastructure**: Can iterate globals but lacks the whole-module usage analysis to safely tighten types. |
| `pick_load_signs.rs` | [PickLoadSigns.cpp](../../../src/passes/PickLoadSigns.cpp) | **5%** | **Stub**: Does not perform the data-flow analysis required to choose optimal load signedness. |
| `simplify.rs` | [Simplify.cpp](../../../src/passes/Simplify.cpp) | **40%** | **Partial**: Handles basic x-x=0 cases; missing 90% of Binaryen's "heavy lifting" logic. |
