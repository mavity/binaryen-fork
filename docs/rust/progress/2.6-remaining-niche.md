# Remaining Passes: Test, Debug & Niche Utilities
**Status**: ðŸ“‹ Planned (Low Priority) | **Passes**: 21 | **Estimated Effort**: Variable (as-needed) | **Target**: On-demand

---

## Overview

This document covers the **21 remaining passes** not included in Tiers 1-5. These are:
- **Test-only passes** used for Binaryen's internal testing infrastructure
- **Debugging utilities** for development and troubleshooting
- **Niche optimizations** for specific, rare use cases
- **Specialized transformations** for particular ecosystems

**Key Characteristic**: These passes are **not required for production use** of the Rust port. They should be implemented **on-demand** when specifically needed, rather than as part of the core implementation roadmap.

---

## Group R1: Test-Only / Internal Passes

**Passes**: 7 | **Priority**: Low (implement only if testing infrastructure needs them)

### Pass List
1. **catch-pop-fixup** â€” Fix nested pops within catch blocks (EH testing)
2. **deinstrument-branch-hints** â€” Remove branch hint instrumentation
3. **delete-branch-hints** â€” Delete branch hints using list of instrumented IDs
4. **experimental-type-generalizing** â€” Generalize types (âš ï¸ not yet sound, testing only)
5. **randomize-branch-hints** â€” Randomize branch hints for fuzzing
6. **reorder-globals-always** â€” Force global reordering even with few globals
7. **reorder-types-for-testing** â€” Use exaggerated cost function for reordering

### Purpose & Context

These passes exist primarily to support **Binaryen's C++ test infrastructure** and fuzzing. They are not optimization passes but rather:
- Testing utilities that exercise edge cases
- Instrumentation helpers for measuring correctness
- Debugging aids for compiler development
- Fuzzing infrastructure for finding bugs

### Implementation Strategy

**Recommendation**: **Do not implement** unless specifically needed for Rust test infrastructure.

**If needed**:
- Implement **only the specific pass required**
- Keep implementation minimal (testing utilities don't need production quality)
- Document as "testing only" to avoid confusion
- Consider alternative approaches using Rust's native testing infrastructure

**Example Alternative**: Instead of implementing `randomize-branch-hints` for fuzzing, use Rust's `proptest` or `quickcheck` to generate randomized IR directly.

### C++ References
- `src/passes/CatchPopFixup.cpp` (~150 lines)
- `src/passes/DeInstrumentBranchHints.cpp` (~100 lines)
- `src/passes/DeleteBranchHints.cpp` (~120 lines)
- `src/passes/TypeGeneralizing.cpp` (~200 lines, experimental)
- `src/passes/RandomizeBranchHints.cpp` (~80 lines)

---

## Group R2: Debugging & Extraction Utilities

**Passes**: 4 | **Priority**: Medium (useful for debugging, implement when needed)

### Pass List
1. **extract-function** â€” Leave just one function (useful for debugging large modules)
2. **extract-function-index** â€” Leave just one function selected by index
3. **roundtrip** â€” Write module to binary, read it back (validation utility)
4. **func-metrics** â€” Report function metrics (size, complexity, etc.)

### Purpose & Context

These are **development and debugging utilities** that help:
- Isolate issues to specific functions (extract-function)
- Validate binary I/O correctness (roundtrip)
- Measure code quality metrics (func-metrics)

Unlike test-only passes, these have **practical use cases for Rust development**:
- Debugging: Extract problematic function from large module
- Validation: Ensure binary writer/reader are inverses
- Profiling: Identify large/complex functions to optimize

### Implementation Strategy

**Recommendation**: Implement **as-needed** when debugging specific issues.

**Priority Order**:
1. **roundtrip** (1-2 days) â€” Highest value, validates binary I/O
2. **func-metrics** (1 day) â€” Useful for profiling and optimization
3. **extract-function** (1 day) â€” Helpful for debugging
4. **extract-function-index** (0.5 day) â€” Variant of extract-function

### Implementation: roundtrip (High Value)

**Purpose**: Validate that writing and reading preserve module semantics

**Algorithm**:
```rust
pub struct RoundTrip;

impl Pass for RoundTrip {
    fn run(&mut self, module: &mut Module) {
        // 1. Write module to binary
        let writer = BinaryWriter::new();
        let binary = writer.write(module).expect("Failed to write");
        
        // 2. Read binary back
        let reader = BinaryReader::new();
        let roundtripped = reader.read(&binary).expect("Failed to read");
        
        // 3. Compare (optional: can just replace module)
        if cfg!(debug_assertions) {
            assert_eq!(module, &roundtripped, "Roundtrip changed module");
        }
        
        // 4. Replace module with roundtripped version
        *module = roundtripped;
    }
}
```

**Testing**:
```rust
#[test]
fn test_roundtrip_preserves_semantics() {
    let original = /* create test module */;
    let mut roundtripped = original.clone();
    
    let mut pass = RoundTrip;
    pass.run(&mut roundtripped);
    
    // Modules should be semantically equivalent
    assert_modules_equivalent(&original, &roundtripped);
}
```

**Impact**: Catches bugs in binary I/O early (critical for Phase 4 binary format work).

---

### Implementation: func-metrics (Medium Value)

**Purpose**: Report statistics about functions (useful for optimization decisions)

**Metrics to Report**:
- Instruction count
- Stack depth
- Number of locals
- Control flow complexity (number of branches)
- Call depth (direct + indirect)

**Algorithm**:
```rust
pub struct FuncMetrics;

impl FuncMetrics {
    fn analyze(func: &Function) -> Metrics {
        Metrics {
            instruction_count: count_instructions(func),
            stack_depth: compute_stack_depth(func),
            local_count: func.vars.len(),
            branch_count: count_branches(func),
            call_count: count_calls(func),
        }
    }
}

impl Pass for FuncMetrics {
    fn run(&mut self, module: &mut Module) {
        println!("Function Metrics:");
        for func in &module.functions {
            let metrics = Self::analyze(func);
            println!("  {}: {:?}", func.name.as_deref().unwrap_or("(anonymous)"), metrics);
        }
    }
}
```

**Use Case**: Identify large functions that need optimization priority.

**C++ Reference**: `src/passes/FunctionMetrics.cpp` (~200 lines)

---

### Implementation: extract-function (Low-Medium Value)

**Purpose**: Remove all functions except one (debugging aid)

**Algorithm**:
```rust
pub struct ExtractFunction {
    target_name: String,
}

impl Pass for ExtractFunction {
    fn run(&mut self, module: &mut Module) {
        // 1. Find target function
        let target_id = module.functions.iter()
            .find(|f| f.name.as_deref() == Some(&self.target_name))
            .map(|f| f.id)
            .expect("Target function not found");
        
        // 2. Remove all other functions
        module.functions.retain(|f| f.id == target_id);
        
        // 3. Clean up exports, imports, etc.
        module.exports.retain(|e| e.target == target_id);
        
        // 4. Remove unused globals, types, etc.
        // (reuse Tier 1 cleanup infrastructure)
    }
}
```

**Use Case**: Isolate problematic function from large module for focused debugging.

**C++ Reference**: `src/passes/ExtractFunction.cpp` (~150 lines)

---

## Group R3: Specialized Alignment & Segments

**Passes**: 3 | **Priority**: Low (niche use cases)

### Pass List
1. **dealign** â€” Force all loads/stores to alignment=1 (testing)
2. **separate-data-segments** â€” Write data segments to separate file
3. **limit-segments** â€” Merge segments to fit web loader limits

### Purpose & Context

**dealign**: Testing utility to stress-test alignment handling. Forces worst-case (unaligned) accesses.

**separate-data-segments**: Optimization for specific deployment scenarios where code and data are loaded separately.

**limit-segments**: Work around browser/loader limitations on number of segments (rare edge case).

### Implementation Strategy

**Recommendation**: **Defer indefinitely** unless specific user request.

These are highly specialized and rarely used even in C++ Binaryen:
- dealign is testing-only
- separate-data-segments is niche deployment optimization
- limit-segments addresses browser bugs (mostly fixed in modern browsers)

**If needed**: Implement on-demand with minimal effort (1-2 days each).

### Implementation: dealign (If Testing Needed)

**Algorithm**:
```rust
pub struct DeAlign;

impl Pass for DeAlign {
    fn run(&mut self, module: &mut Module) {
        for func in &mut module.functions {
            for expr in func.walk_mut() {
                match &mut expr.kind {
                    ExpressionKind::Load { align, .. } => *align = 1,
                    ExpressionKind::Store { align, .. } => *align = 1,
                    _ => {}
                }
            }
        }
    }
}
```

**C++ Reference**: `src/passes/DeAlign.cpp` (~80 lines)

---

## Group R4: Niche Optimizations

**Passes**: 4 | **Priority**: Low-Medium (specialized scenarios)

### Pass List
1. **once-reduction** â€” Reduce calls to code that only runs once
2. **enclose-world** â€” Destructive closed-world modifications
3. **set-globals** â€” Set specified globals to values (testing/specialized)
4. **duplicate-import-elimination** â€” Remove duplicate imports

### Purpose & Context

**once-reduction**: Optimization for startup code that runs exactly once. Rare in WebAssembly (more common in native code).

**enclose-world**: Aggressive whole-program optimization assuming no external observers. Destructive (breaks exports), only useful for specific scenarios.

**set-globals**: Testing/debugging utility to force global values.

**duplicate-import-elimination**: Simple cleanup pass (similar to Tier 1 remove-unused-* passes).

### Implementation Strategy

**Priority**:
1. **duplicate-import-elimination** (1 day) â€” Can be included in Tier 1 if time permits
2. **once-reduction** (2-3 days) â€” If optimizing startup code becomes priority
3. **set-globals** (0.5 day) â€” Only if testing infrastructure needs it
4. **enclose-world** (3-4 days) â€” Only for highly specialized use cases

### Implementation: duplicate-import-elimination (Easiest)

**Algorithm**:
```rust
pub struct DuplicateImportElimination;

impl Pass for DuplicateImportElimination {
    fn run(&mut self, module: &mut Module) {
        let mut seen = HashMap::new();
        let mut to_remove = Vec::new();
        
        for (idx, import) in module.imports.iter().enumerate() {
            let key = (import.module.clone(), import.base.clone());
            if let Some(&first_idx) = seen.get(&key) {
                // Duplicate found, redirect all uses to first import
                to_remove.push(idx);
                redirect_import_uses(module, idx, first_idx);
            } else {
                seen.insert(key, idx);
            }
        }
        
        // Remove duplicates
        for idx in to_remove.into_iter().rev() {
            module.imports.remove(idx);
        }
    }
}
```

**Value**: Minor code size reduction (few bytes per duplicate).

**C++ Reference**: `src/passes/DuplicateImportElimination.cpp` (~150 lines)

---

### Implementation: once-reduction (Niche)

**Purpose**: Optimize functions that are called exactly once

**Algorithm**:
1. Build call graph
2. Identify functions called once (excluding recursion, indirect calls)
3. For each once-called function:
   - If small enough, inline it
   - Otherwise, mark for specialized optimization
4. Clean up unused code after inlining

**Heuristic**: Only inline if:
- Called exactly once
- Not too large (< 100 instructions)
- No side effects that prevent inlining

**C++ Reference**: `src/passes/OnceReduction.cpp` (~250 lines)

**Note**: Inlining infrastructure from Tier 4 can be reused for implementation.

---

## Group R5: Instrumentation & Branch Hints

**Passes**: 3 | **Priority**: Low (specialized instrumentation)

### Pass List
1. **instrument-branch-hints** â€” Instrument branch hints to track correctness
2. **remove-non-js-ops** â€” Remove operations incompatible with JS
3. **stub-unsupported-js** â€” Stub out unsupported JS operations

### Purpose & Context

**instrument-branch-hints**: Measure branch prediction hint accuracy (testing/profiling).

**remove-non-js-ops** / **stub-unsupported-js**: Compatibility passes for JavaScript environments. Overlap with Tier 5 JS interop passes but more aggressive/destructive.

### Implementation Strategy

**Recommendation**: Implement only if specific JS interop issues arise.

**remove-non-js-ops** and **stub-unsupported-js** are covered by Tier 5's `optimize-for-js` and `legalize-js-interface` in most cases. These are more aggressive variants for edge cases.

**instrument-branch-hints** is profiling infrastructure, not needed unless doing performance analysis of branch hints specifically.

**If needed**: 1-2 days each, leveraging Visitor pattern.

### Implementation: remove-non-js-ops (If Needed)

**Algorithm**:
```rust
pub struct RemoveNonJSOps;

impl Pass for RemoveNonJSOps {
    fn run(&mut self, module: &mut Module) {
        for func in &mut module.functions {
            for expr in func.walk_mut() {
                match expr.kind {
                    // Replace i64 operations with i32 pairs or remove
                    ExpressionKind::Binary { op: BinaryOp::AddInt64, .. } => {
                        // Convert to i32 or remove
                    }
                    // Remove SIMD operations
                    ExpressionKind::SIMDExtract { .. } => {
                        // Replace with unreachable or stub
                    }
                    _ => {}
                }
            }
        }
    }
}
```

**Note**: This is **destructive** and should only be used when absolutely necessary. Prefer Tier 5's `i64-to-i32-lowering` for safer transformation.

**C++ Reference**: `src/passes/RemoveNonJSOps.cpp` (~300 lines)

---

## Implementation Timeline & Strategy

### When to Implement Each Group

**Immediate** (Week 1-2, alongside Tier 1 if time permits):
- duplicate-import-elimination (fits naturally with Tier 1 cleanup)

**Short-term** (Weeks 3-8, if debugging needs arise):
- roundtrip (validates binary I/O, critical for Phase 4)
- func-metrics (useful for optimization profiling)
- extract-function (debugging aid)

**Medium-term** (Weeks 10-20, if specific issues arise):
- once-reduction (if startup optimization becomes priority)
- remove-non-js-ops (if JS interop issues not covered by Tier 5)

**Long-term / Never** (implement only on specific user request):
- All test-only passes (Group R1)
- dealign, separate-data-segments, limit-segments (Group R3)
- enclose-world, set-globals (Group R4 niche)
- instrument-branch-hints, stub-unsupported-js (Group R5)

---

## Total Effort Estimate

| Group | Passes | Priority | Effort (if implemented) |
|-------|--------|----------|------------------------|
| R1: Test-Only | 7 | Very Low | 7-10 days (if all implemented) |
| R2: Debugging | 4 | Medium | 3-4 days |
| R3: Alignment/Segments | 3 | Low | 3-5 days |
| R4: Niche Opts | 4 | Low-Medium | 6-10 days |
| R5: Instrumentation | 3 | Low | 3-5 days |
| **Total** | **21** | | **22-34 days** |

**Realistic Estimate**: Only 5-8 of these will ever be implemented (roundtrip, func-metrics, extract-function, duplicate-import-elimination, once-reduction).

**Adjusted Effort**: ~8-12 days for the useful subset.

---

## Recommendation

### Do NOT Include in Roadmap

These passes should **not** be part of the main Tier 1-5 implementation plan because:
1. Not required for production use
2. Minimal user-facing value
3. Test/debug utilities that Rust can handle differently
4. Niche edge cases (browser bugs, specialized deployments)

### Implement On-Demand

**Suggested Process**:
1. User reports specific issue or requests specific pass
2. Evaluate if pass truly needed or if alternative solution exists
3. If needed, implement minimal version (don't over-engineer)
4. Document as "on-demand" or "testing utility"

### Prioritize These 5 (If Time Available)

If resources allow after Tier 4, consider implementing:
1. **roundtrip** â€” Validates binary I/O correctness
2. **func-metrics** â€” Profiling aid for optimization
3. **extract-function** â€” Debugging large modules
4. **duplicate-import-elimination** â€” Small code size win
5. **once-reduction** â€” Niche but legitimate optimization

**Total Effort**: ~8 days (can be done incrementally)

---

## Testing Strategy

For any implemented pass from this group:

**Minimal Testing** (sufficient for utilities):
- One basic functionality test
- One edge case test (empty module, single function, etc.)
- No need for extensive coverage (these aren't core optimizations)

**Example Test**:
```rust
#[test]
fn test_extract_function() {
    let mut module = create_test_module_with_3_functions();
    
    let mut pass = ExtractFunction::new("target_func");
    pass.run(&mut module);
    
    assert_eq!(module.functions.len(), 1);
    assert_eq!(module.functions[0].name, Some("target_func"));
}
```

---

## Conclusion

The 21 remaining passes are **not critical for Rust port success**. They represent:
- **7 test-only** passes (skip entirely)
- **4 debugging utilities** (implement 3 if time permits)
- **3 specialized** alignment/segment passes (skip unless requested)
- **4 niche optimizations** (implement 2 if time permits)
- **3 instrumentation** passes (skip unless specific need)

**Impact on Timeline**: These passes **do not affect the core roadmap**. The Rust port achieves production readiness (75% parity) at the end of Tier 4 without any of these passes.

**Final Recommendation**: 
- Mark these as "Tier R" (Remaining/On-Demand)
- Document as deferred
- Implement only if specific user need arises
- Focus all effort on Tiers 1-4 for production readiness

---

## Cross-Reference

**Main Planning Documents**:
- `2-gap-analysis.md` â€” Overall strategy and timeline
- `2.1-tier1-foundational.md` through `2.5-tier5-specialized.md` â€” Core implementation tiers
- `README-PASSES.md` â€” Navigation guide

**This Document's Role**: Comprehensive coverage of all passes for completeness, but explicit recommendation to defer most of them indefinitely.
