# 3.2 Triad Test Plan ‚úÖ

## Overview üí°
This document describes the design and implementation plan for a **triad test** system for `binaryen-decompile`. These tests automatically compile small Rust source files into WebAssembly, decompile the resulting WASM into both Rust and C++, and verify the output against "gold" files stored in the same directory. The tests are generated by a procedural macro to ensure easy discovery and integration with `cargo test`.

---

## Goals üéØ
- Create repeatable regression tests that exercise the full path: **Rust Source -> WASM -> Decompiler -> Rust/C++ Gold Files**.
- Generate one test case per input file for granular reporting.
- Fail tests on compilation errors (e.g., `rustc` failures) and provide captured error output.
- Assert strict equality between decompiler output and gold files using unified diffs for debugging.

---

## High-level Design üèóÔ∏è
- Use the existing `binaryen-macros` crate to expose a `#[triad_tests]` attribute.
- **Input Strategy**:
  - The macro scans the `rust/binaryen-decompile/tests` directory.
  - It identifies files matching `_*.rs`.
  - It **excludes** files ending in `.roundtrip.rs`.
- **Test Generation**:
  - For each valid `_foo.rs`, the macro generates a `#[test] fn triad_foo()`.
- **Execution Flow (per test)**:
  1. **Compile**: Invoke `rustc --target=wasm32-unknown-unknown` on `_foo.rs`. The output WASM should be kept in a temporary location outside of git tracking (e.g., `std::env::temp_dir()`).
  2. **Decompile**: Load the WASM into `binaryen-decompile`, run the `Lifter`, and produce:
     - Rust code (using `RustPrinter`).
     - C++ code (using `CPrinter`).
  3. **Compare**:
     - Compare produced Rust against `_foo.roundtrip.rs`.
     - Compare produced C++ against `_foo.roundtrip.cpp`.
  4. **Fail**: If matches fail, or if gold files are missing, the test fails with a clear diff.

---

## Implementation Steps üõ†Ô∏è

### 1. Proc-Macro (`binaryen-macros`)
- Implement `#[triad_tests]` to:
  - Enumerate `rust/binaryen-decompile/tests/_*.rs` (excluding `*.roundtrip.rs`).
  - Emit one `#[test]` function per file.
  - The generated code calls a runtime helper function `run_triad_test(source_path)`.

### 2. Runtime Harness (`binaryen-decompile`)
- Implement `run_triad_test(path: &Path)`:
  - Determine output paths: `path.with_extension("roundtrip.rs")` and `path.with_extension("roundtrip.cpp")`.
  - Create a temporary file for the `.wasm` output.
  - Run `rustc -O --target=wasm32-unknown-unknown -o <temp>.wasm <path>`.
  - On `rustc` failure, panic with `stderr`.
  - Decompile `<temp>.wasm` to strings.
  - Load gold files from disk.
  - Perform `assert_eq!` or use a diffing crate for better error messages.

### 3. Integration
- Add `binaryen-macros` as a `dev-dependency` to `binaryen-decompile`.
- Use the macro in `rust/binaryen-decompile/tests/triad_tests.rs`.

---

## Naming Convention üìù
- **Source**: `_filename.rs`
- **Rust Gold**: `_filename.roundtrip.rs`
- **C++ Gold**: `_filename.roundtrip.cpp`

The leading underscore prevents these test files from being treated as standard modules by the Rust compiler during normal builds, while keeping them grouped in the `tests/` directory.

---

## Next Steps ‚úÖ
1. Create the `triad_tests` macro in `rust/binaryen-macros`.
2. Implement the `run_triad_test` helper in `rust/binaryen-decompile/tests/common/mod.rs` (or similar).
3. Add the first triad test case (e.g., `_add.rs` and its gold files).
4. Verify that `cargo test` correctly picks up and executes the generated tests.
