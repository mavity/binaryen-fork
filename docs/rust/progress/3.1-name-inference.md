# High-Performance Variable Name Inference Engine

## Scope
This document defines the high-performance implementation plan for inferring meaningful names for **function parameters and local variables**. The engine is optimized for memory locality and throughput, focusing strictly on local-scope entities.

**In Scope:**
- Local variables (declared within function bodies)
- Function parameters (the arguments to a function)

**Explicitly Out of Scope:**
- Function names (omitted or mangled)
- Type names (structural type detection)
- Global variable names

This focused scope ensures the implementation remains lean and delivers immediate value for variable readability without the complexity of cross-functional analysis.

---

## Data Structures (Memory Optimized)

To ensure maximum cache efficiency when processing functions with high local counts, the engine uses a compact, fixed-width data-oriented model.

### Variable Stats Struct
This struct resides in a flat array (one per local/parameter) to ensure linear memory access and optimal prefetching.

```rust
/// Compact representation of variable usage and hints.
/// Size: 16 bytes.
#[repr(C)]
pub struct VariableStats {
    /// Semantic scores (0-255) for each trait (e.g., Index, Buffer, etc.)
    /// Allows the entire function forensics to fit into L1/L2 caches.
    pub trait_scores: [u8; 8],
    
    /// Global string table ID for the current best name hint.
    pub name_hint_id: u32, 
    
    /// Confidence level (0-255) of the name hint.
    pub hint_confidence: u8,
    
    /// Reserved for alignment or flags.
    _padding: [u8; 3],
}
```

### Semantic Traits (TraitType)
Traits are "buckets" for competing semantic identities identified from WASM instruction patterns:

| Index | Trait | Typical Pattern |
| --- | --- | --- |
| 0 | **Index** | i32.add(v, 1), br_if loop conditions. |
| 1 | **Buffer** | Base operand of load or store. |
| 2 | **Offset** | Result of ptr + const or local.get in memory indexing. |
| 3 | **Boolean** | Output of eqz, input to select, if. |
| 4 | **Length** | Upper bound in comparison with an Index trait. |
| 5 | **Bitmask** | Bitwise and/or with constant masks. |
| 6 | **Handle** | Returned from or passed to specific WASI-style functions. |
| 7 | **Accumulator** | Repeated reduction/mutation in a non-loop-bound context. |

---

## Architecture: Inference Pipeline

Naming is performed in three high-speed sequential passes.

### Pass 1: Semantic Trait Analysis
A linear disassembly scan identifying instruction patterns.
- **Action:** Increments specific trait_scores based on instruction local usage.
- **Example:** If local.get $v is the pointer operand for an i32.load, v.trait_scores[Buffer] is incremented by a weight (e.g., +40).
- **Performance:** O(I) complexity (constant time per instruction).

### Pass 2: Flow-Based Hint Propagation
A data-flow sub-pass that propagates identity hints (from parameters or function return metadata) through the local variables.

- **Sources (Hints):**
    - **Inbound:** Function parameters (if metadata is available).
    - **Outbound:** Sink logic (e.g., passing a variable to free() grants it a ptr hint).
- **Propagation Logic:**
    When local.set $B (local.get $A) is detected:
    - If A.hint_confidence > B.hint_confidence:
        - B.name_hint_id = A.name_hint_id
        - B.hint_confidence = A.hint_confidence * 0.85 (Confidence Decay).
- **Result:** Semantic identity (like timeout) flows naturally across variable handoffs.

### Pass 3: Semantic ID Synthesis
The winner trait and best hint are combined into a language-agnostic SemanticID.

```rust
pub struct SemanticID {
    /// The best name hint found (if any).
    pub base_hint_id: u32,
    /// The dominant semantic trait inferred from patterns.
    pub primary_trait: TraitType,
    /// Final confidence aggregate.
    pub confidence: u8,
}
```

---

## Formatting: Linguistic Flexibility

Standardizing the name according to target language conventions (u-Rust vs. C) is handled by a NameFormatter trait.

```rust
pub trait NameFormatter {
    /// Formats the raw SemanticID into a valid identifier for the target language.
    /// Handles collision suffixes (e.g., ptr_0, ptr_1).
    fn format(&self, id: &SemanticID, local_idx: u32) -> String;
}
```

### Style Comparison:

| Trait | C-Style Formatter | u-Rust Formatter |
| --- | --- | --- |
| **Index** | i, n, index | i, idx, _iter |
| **Buffer** | p, ptr, buf | _buf, buffer |
| **Boolean** | flag, ok, done | is_, has_, valid |

---

## Implementation Roadmap

### Phase 1: Data-Oriented Foundation
1. Implement VariableStats array in the Analysis context.
2. Build the SemanticTrait enum and score increment logic.

### Phase 2: Pattern Recognition
3. Implement InstructionVisitor to recognize common semantic patterns (Increment, Pointer-Arithmetic, Condition-Bounds).
4. Write unit tests for trait scoring accuracy.

### Phase 3: Identity Flow
5. Implement the propagation sub-pass for name hints.
6. Configure DECAY_FACTOR to prevent hints from "overtaking" strongly defined semantic variables.

### Phase 4: Resolution & Formatting
7. Implement NameFormatter for C and Rust output styles.
8. Build a collision resolution map to handle multiple ptr candidates.

---

## Constraints & Requirements
- **Efficiency:** Processing 1,000 locals must fit in L1 cache (~16KB stats array).
- **Accuracy:** Conflicts between a "Hint" (what it is named) and a "Trait" (how it is used) should favor high-confidence Traits to detect developer obfuscation or optimized reuse.
- **Portability:** The result of the inference engine must be a data map, not a modified string in the AST.
