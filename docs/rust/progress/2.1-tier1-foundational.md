# Tier 1: Foundational & Cleanup Passes
**Status**: ðŸ“‹ Planned | **Passes**: 19 | **Estimated Effort**: 2â€“3 weeks | **Target**: Week 1-2

---

## Overview

Tier 1 consists of straightforward removal, reordering, and metadata operations that:
- Require no complex tree manipulation
- Build essential reusable infrastructure (UsageTracker, ModuleStats)
- Have minimal dependencies on other passes
- Provide immediate value (dead code removal, better compression via reordering)

**Key Principle**: These passes are **parallelizable** â€” multiple team members can implement different groups simultaneously after shared infrastructure is in place.

---

## Group 1A: Dead Code & Unused Element Removal

**Passes**: 7 | **Effort**: 2 days each = 14 days | **Dependencies**: None

### Pass List
1. **remove-unused-module-elements** â€” Remove unused functions, globals, data segments
2. **remove-unused-brs** â€” Eliminate branches to labels that are never used
3. **remove-unused-names** â€” Strip debug names from locations never branched to
4. **remove-unused-types** â€” Eliminate unreachable type definitions (GC types)
5. **remove-imports** â€” Strip unused imports (configurable)
6. **remove-memory-init** / **remove-memory** â€” Remove data segment initialization
7. **vacuum** â€” Bulk removal of obviously unneeded code

### Shared Infrastructure

**UsageTracker** (1 day, reusable across all 7 passes):
```rust
// rust/binaryen-ir/src/analysis/usage.rs

pub struct UsageTracker {
    function_refs: HashSet<FunctionId>,
    global_refs: HashSet<GlobalId>,
    type_refs: HashSet<TypeId>,
    local_refs: HashMap<FunctionId, HashSet<LocalId>>,
    label_refs: HashMap<FunctionId, HashSet<String>>,
}

impl UsageTracker {
    pub fn analyze(module: &Module) -> Self { /* ... */ }
    pub fn is_used_function(&self, id: FunctionId) -> bool { /* ... */ }
    pub fn is_used_global(&self, id: GlobalId) -> bool { /* ... */ }
    pub fn is_used_type(&self, id: TypeId) -> bool { /* ... */ }
    pub fn unused_functions(&self) -> Vec<FunctionId> { /* ... */ }
}
```

**Implementation Pattern** (same for all 7 passes):
1. Run UsageTracker on module
2. Identify unused elements of specific category
3. Filter/remove from module's collections
4. Update indices if needed

### C++ Reference Files
- `src/passes/RemoveUnusedModuleElements.cpp` (~200 lines)
- `src/passes/RemoveUnusedBrs.cpp` (~150 lines)
- `src/passes/RemoveUnusedNames.cpp` (~100 lines)
- `src/passes/Vacuum.cpp` (~300 lines)

### Testing Strategy
Each pass should have:
- **Unit test**: Construct small module with unused elements, run pass, verify removal
- **Preservation test**: Module with all elements used, verify no changes
- **Edge case test**: Empty module, module with circular references

**Example Test**:
```rust
#[test]
fn test_remove_unused_functions() {
    let bump = Bump::new();
    let mut module = Module::new();
    
    // Add function "used" (called from export)
    let used_fn = Function::new(/* ... */);
    module.add_function(used_fn);
    
    // Add function "unused" (not referenced)
    let unused_fn = Function::new(/* ... */);
    module.add_function(unused_fn);
    
    // Add export that references "used"
    module.add_export(Export { name: "main", target: used_fn.id });
    
    // Run pass
    let mut pass = RemoveUnusedModuleElements::new();
    pass.run(&mut module);
    
    // Verify
    assert!(module.get_function(used_fn.id).is_some());
    assert!(module.get_function(unused_fn.id).is_none());
}
```

### Success Criteria
- âœ… All 7 passes pass unit tests
- âœ… UsageTracker has 100% code coverage
- âœ… No regressions in existing 300+ tests
- âœ… Documentation: Each pass has docstring explaining what it removes

---

## Group 1B: Type & Global Reorganization

**Passes**: 5 | **Effort**: 1-2 days each = 5-10 days | **Dependencies**: None

### Pass List
1. **reorder-types** â€” Sort types by usage frequency for better compression
2. **reorder-locals** â€” Sort locals to improve LEB128 encoding
3. **reorder-globals** â€” Reorder globals by access frequency
4. **reorder-functions** / **reorder-functions-by-name** â€” Sort functions for locality/debugging
5. **minify-imports** / **minify-imports-and-exports** â€” Shorten import/export names

### Shared Infrastructure

**ModuleStats** (1 day, reusable):
```rust
// rust/binaryen-ir/src/analysis/stats.rs

pub struct ModuleStats {
    type_counts: HashMap<TypeId, usize>,    // How many times each type is referenced
    global_counts: HashMap<GlobalId, usize>, // Global access frequency
    function_counts: HashMap<FunctionId, usize>, // Call frequency
}

impl ModuleStats {
    pub fn collect(module: &Module) -> Self { /* Walk module, count references */ }
    pub fn sorted_types(&self) -> Vec<TypeId> { /* Sort by count descending */ }
}
```

### Implementation Pattern
1. Collect statistics (ModuleStats)
2. Sort elements by desired criterion (frequency, name, etc.)
3. Rebuild module collections in new order
4. Update all references (indices change)

### C++ Reference Files
- `src/passes/ReorderTypes.cpp` (~150 lines)
- `src/passes/ReorderLocals.cpp` (~200 lines)
- `src/passes/ReorderGlobals.cpp` (~180 lines)
- `src/passes/ReorderFunctions.cpp` (~150 lines)
- `src/passes/MinifyImports.cpp` (~300 lines)

### Testing Strategy
- **Sorting test**: Verify elements are in expected order after pass
- **Preservation test**: Behavior unchanged (module semantics identical)
- **Index update test**: All references correctly updated after reordering

**Example Test**:
```rust
#[test]
fn test_reorder_globals_by_frequency() {
    let mut module = Module::new();
    
    // Add global "cold" (used once)
    let cold = module.add_global(Global::new(Type::I32, /* ... */));
    // Add global "hot" (used 100 times)
    let hot = module.add_global(Global::new(Type::I32, /* ... */));
    
    // Add function that uses "hot" 100 times
    let func = /* ... create function with 100 global.get(hot) ... */;
    
    // Run pass
    let mut pass = ReorderGlobals::new();
    pass.run(&mut module);
    
    // Verify: "hot" should now be at index 0 (first)
    assert_eq!(module.globals[0].id, hot);
    assert_eq!(module.globals[1].id, cold);
}
```

### Success Criteria
- âœ… All 5 passes correctly reorder elements
- âœ… ModuleStats accurately counts references
- âœ… Validation: Module validates before and after reordering
- âœ… Binary size test: Reordered module compresses better (measure with gzip)

---

## Group 1C: Metadata & Name Handling

**Passes**: 7 | **Effort**: 1-2 days each = 7-14 days | **Dependencies**: None

### Pass List
1. **name-types** â€” Assign stable names to heap types
2. **nm** (name-list) â€” Generate name list for debugging
3. **propagate-debug-locs** â€” Propagate DWARF location info through tree
4. **strip-debug** â€” Remove debug info including names section
5. **strip-dwarf** â€” Remove DWARF sections specifically
6. **emit-target-features** â€” Write target features section
7. **print** / **print-minified** / **print-full** / **print-call-graph** / **print-function-map** â€” Various output formats

### Implementation Notes

These passes primarily deal with metadata and output rather than optimization. They can be implemented independently and in parallel.

**Key Patterns**:
- **strip-*** passes: Walk module, remove specific sections/metadata
- **print-*** passes: Output formatters (S-expression, call graph, etc.)
- **name-types**: Assign deterministic names based on structure
- **propagate-debug-locs**: Tree walker that copies location metadata from parents to children

### C++ Reference Files
- `src/passes/NameTypes.cpp` (~250 lines)
- `src/passes/StripDebug.cpp` (~150 lines)
- `src/passes/StripDWARF.cpp` (~100 lines)
- `src/passes/Printer.cpp` (~400 lines)
- `src/passes/PrintCallGraph.cpp` (~200 lines)

### Testing Strategy
- **Metadata preservation**: Ensure passes don't affect execution semantics
- **Output validation**: For print passes, verify output format correctness
- **Round-trip test**: For strip passes, ensure stripped module still validates

**Example Test**:
```rust
#[test]
fn test_strip_debug_removes_names() {
    let mut module = Module::new();
    
    // Add function with name
    let mut func = Function::new(/* ... */);
    func.name = Some("my_function".to_string());
    module.add_function(func);
    
    // Add local with name
    func.vars[0].name = Some("my_local".to_string());
    
    // Run pass
    let mut pass = StripDebug::new();
    pass.run(&mut module);
    
    // Verify: names removed
    assert!(module.functions[0].name.is_none());
    assert!(module.functions[0].vars[0].name.is_none());
}
```

### Success Criteria
- âœ… Strip passes correctly remove targeted metadata
- âœ… Print passes produce valid output matching C++ format
- âœ… Propagate-debug-locs correctly inherits location info
- âœ… No semantic changes to module execution

---

## Implementation Sequence & Timeline

### Week 1: Infrastructure & First Wins (5 working days)

**Day 1**: Build shared infrastructure
- Implement UsageTracker (morning)
- Implement ModuleStats (afternoon)
- Write comprehensive unit tests for both

**Day 2-3**: Group 1A implementation (2 passes per day)
- Day 2: `vacuum` + `remove-unused-module-elements`
- Day 3: `remove-unused-brs` + `remove-unused-names`

**Day 4-5**: Finish Group 1A + Start Group 1B
- Day 4: `remove-unused-types` + `remove-imports` + `remove-memory-init`
- Day 5: `reorder-types` + `reorder-locals`

**Deliverable**: 9 passes operational, reusable infrastructure in place

---

### Week 2: Reordering & Metadata (5 working days)

**Day 1-2**: Complete Group 1B
- Day 1: `reorder-globals` + `reorder-functions`
- Day 2: `minify-imports` (more complex, needs name mapping)

**Day 3-5**: Group 1C (1.5 passes per day)
- Day 3: `name-types` + `nm`
- Day 4: `strip-debug` + `strip-dwarf` + `emit-target-features`
- Day 5: `propagate-debug-locs` + `print` + testing/polish

**Deliverable**: All 19 Tier 1 passes complete, tested, documented

---

## Validation & Quality Gates

Before marking Tier 1 complete:

### Code Quality
- [ ] All 19 passes have docstrings explaining purpose
- [ ] Shared infrastructure (UsageTracker, ModuleStats) has >90% test coverage
- [ ] No clippy warnings
- [ ] Code formatted with `cargo fmt`

### Testing
- [ ] Each pass has â‰¥3 unit tests (basic, edge case, preservation)
- [ ] Integration test: Run all 19 passes on a real-world module
- [ ] No regressions: All existing 300+ tests still pass
- [ ] Fuzzing: Add fuzzer target that randomly enables/disables Tier 1 passes

### Documentation
- [ ] Update `2-gap-analysis.md` to mark Tier 1 complete
- [ ] Add examples to each pass docstring
- [ ] Document shared infrastructure APIs

### Performance
- [ ] UsageTracker completes in <1ms on 10KB module
- [ ] ModuleStats completes in <5ms on 10KB module
- [ ] All passes together complete in <50ms on 10KB module

---

## Risk Mitigation

### Risk: Index invalidation bugs after reordering
**Mitigation**: 
- Implement IndexMap utility that tracks and updates all references
- Add validation step after reordering (assert all indices valid)
- Write fuzzer that checks module validity before/after

### Risk: Incomplete usage tracking misses references
**Mitigation**:
- Use exhaustive match on ExpressionKind to ensure all cases covered
- Add test that intentionally creates module with every possible reference type
- Review C++ implementation for edge cases

### Risk: Metadata passes break validation
**Mitigation**:
- Run validator before and after every pass in tests
- Ensure strip passes only remove metadata, not semantic content
- Test with modules that have no metadata (should be no-op)

---

## Expected Outcomes

### Quantitative
- **19 passes implemented** (from 6 to 25 total)
- **Functional parity**: ~20% of C++ optimization capability
- **Code size reduction**: 5-10% from dead code removal + reordering
- **Build time**: UsageTracker enables faster incremental builds

### Qualitative
- **Infrastructure foundation**: UsageTracker and ModuleStats reusable for Tier 2+
- **Team confidence**: Parallelizable work proves Rust port is tractable
- **Testing discipline**: Pattern established for all future passes

### Integration
- These passes unlock Tier 2 by cleaning up IR before complex transformations
- Reordering passes improve compression (helpful for binary I/O testing)
- Metadata passes enable better debugging of Tier 2+ implementations

---

## Next Steps After Tier 1

With Tier 1 complete, you have:
- âœ… Clean IR (unused elements removed)
- âœ… Optimized layout (reordered for compression)
- âœ… Reusable tracking infrastructure

**Natural progression**: Move to **Tier 2 (Local & Block Optimizations)**, which builds on this foundation to optimize within individual functions.

See `2.2-tier2-local-block.md` for details.

# Missing or incomplete Passes after initial work done

Tier 1 is now nearly 100% complete. Group 1B (Reordering) and Group 1A (Cleanup) are fully functional logic ports. Group 1C (Metadata/Printing) is fully implemented for standard workflows, including standard WAT printing and comprehensive name minification/debug-info stripping.

### Tier 1 Pass Maturity Matrix

| Rust Pass File | Equivalent C++ Implementation | Port % | Critical Gap / Missing Piece |
| :--- | :--- | :--- | :--- |
| `remove_unused_module_elements.rs` | [RemoveUnusedModuleElements.cpp](../../../src/passes/RemoveUnusedModuleElements.cpp) | **100%** | Comprehensive pruning of functions, globals, imports, segments, and types. Handles transitive closure and index remapping. |
| `remove_unused_types.rs` | [RemoveUnusedTypes.cpp](../../../src/passes/RemoveUnusedTypes.cpp) | **100%** | Fully functional; uses `ModuleStats` to identify and prune unused type definitions, remapping all refs and signatures. |
| `remove_unused_brs.rs` | [RemoveUnusedBrs.cpp](../../../src/passes/RemoveUnusedBrs.cpp) | **100%** | Robust flow-based optimization. Handles redundant breaks, unreachable code truncation, and block fallthrough simplification. |
| `remove_unused_names.rs` | [RemoveUnusedNames.cpp](../../../src/passes/RemoveUnusedNames.cpp) | **100%** | Prunes unused labels from blocks, loops, and switch expressions. Respects WASM shadowing rules. |
| `remove_imports.rs` | [RemoveImports.cpp](../../../src/passes/RemoveImports.cpp) | **100%** | Tracks import usage, replaces calls with side-effect-aware placeholders, and remaps indices. |
| `remove_memory_init.rs` | [RemoveMemoryInit.cpp](../../../src/passes/RemoveMemoryInit.cpp) | **100%** | Fully implements segment removal, start function clearing, and index-aware function removal/remapping. |
| `vacuum.rs` | [Vacuum.cpp](../../../src/passes/Vacuum.cpp) | **100%** | Recursive simplification using `EffectAnalyzer`. Handles block flattening, `if`-condition folding, and dead-expression pruning. |
| `simplify_identity.rs` | [SimplifyIdentity.cpp](../../../src/passes/SimplifyIdentity.cpp) | **100%** | Extensive identities for arithmetic, bitwise, ref types (RefAs, RefCast, RefEq), and EqZ triple-nesting. |
| `reorder-*` | [ReorderTypes.cpp](../../../src/passes/ReorderTypes.cpp) | **100%** | Usage-based sorting for Types, Globals, and Functions, plus grouping for Locals, with full module-wide index remapping. |
| `minify-names` | [MinifyImports.cpp](../../../src/passes/MinifyImports.cpp) | **100%** | Robust minification for internal names (functions, globals, locals, and branch labels). Updates all name references. |
| `strip-* / print-*` | [StripDebug.cpp](../../../src/passes/StripDebug.cpp) | **95%** | `StripDebug` and `StripDWARF` are fully functional; `PropagateDebugLocs` implements location inheritance; `Print` uses industry-standard `wasmprinter`. |

### Remaining Gaps in Tier 1

While the core logic of Tier 1 is now complete, a few minor metadata and specialized utilities remain:
1. **NameTypes** (`metadata.rs`): Currently a placeholder. Needs to assign deterministic names to heap types for debug output.
2. **EmitTargetFeatures** (`metadata.rs`): Placeholder. Should ensure the target features section is correctly synchronized before emission.
3. **Specialized Printers**: While WAT printing is standard via `wasmprinter`, specialized debug printers (e.g., `print-call-graph`, `nm`) are currently missing or very basic.
4. **Validation Integration**: The "Binary Bridge" used for printing ensures output validity, but deeper IR-level validation (WASM validation on the Rust IR itself) is still being refined in `wasm-validator.rs`.

