# Tier 4: Advanced Analysis & Transforms
**Status**: ðŸ“‹ Planned | **Passes**: 28 | **Estimated Effort**: 4â€“8 weeks | **Target**: Week 15-22

---

## Overview

Tier 4 implements sophisticated whole-function and whole-module analyses that enable high-impact transformations like inlining, SSA-based optimizations, and global analysis. These passes require substantial infrastructure but deliver significant performance improvements.

**Key Requirement**: Call graph analysis, SSA construction, and inter-procedural analysis infrastructure.

---

## Group 4A: Inlining & Code Specialization

**Passes**: 7 | **Effort**: 30-35 days

### Pass List
1. **inlining** â€” Basic function inlining
2. **inlining-optimizing** â€” Inlining + optimize at call sites
3. **inline-main** â€” Inline __original_main into main
4. **outlining** â€” Extract common code into functions (inverse of inlining)
5. **duplicate-function-elimination** â€” Merge identical functions
6. **merge-similar-functions** â€” Merge near-identical functions
7. **monomorphize** / **monomorphize-always** â€” Specialize polymorphic functions
8. **no-inline** / **no-full-inline** / **no-partial-inline** â€” Mark functions non-inlineable

### Shared Infrastructure: Call Graph (2-3 days)

```rust
// rust/binaryen-ir/src/analysis/call_graph.rs

pub struct CallGraph {
    /// Direct calls from each function
    calls: HashMap<FunctionId, HashSet<FunctionId>>,
    
    /// Functions that call this function
    callers: HashMap<FunctionId, HashSet<FunctionId>>,
    
    /// Indirect calls (call_indirect)
    indirect_calls: Vec<(FunctionId, ExprRef)>,
}

impl CallGraph {
    pub fn build(module: &Module) -> Self { /* ... */ }
    
    /// Find all functions called from this function
    pub fn callees(&self, func: FunctionId) -> &HashSet<FunctionId> { /* ... */ }
    
    /// Is function recursive (directly or indirectly)?
    pub fn is_recursive(&self, func: FunctionId) -> bool { /* ... */ }
    
    /// Topological sort for bottom-up analysis
    pub fn topological_order(&self) -> Vec<FunctionId> { /* ... */ }
}
```

### Cost Estimator (2 days)

```rust
// rust/binaryen-ir/src/analysis/cost.rs

pub struct CostEstimator;

impl CostEstimator {
    /// Estimate cost of inlining this function
    pub fn inline_cost(func: &Function) -> Cost {
        Cost {
            instruction_count: count_instructions(func),
            stack_depth: max_stack_depth(func),
            call_count: count_calls(func),
            complexity: estimate_control_flow_complexity(func),
        }
    }
    
    /// Should we inline this call site?
    pub fn should_inline(&self, caller: &Function, callee: &Function, call_site: ExprRef) -> bool {
        let cost = Self::inline_cost(callee);
        
        // Heuristics:
        // - Always inline tiny functions (<10 instructions)
        // - Inline hot functions if cost reasonable
        // - Don't inline if caller already huge
        // - Don't inline recursive calls
        
        cost.instruction_count < 10 
            || (self.is_hot(callee) && cost.instruction_count < 100)
            && !self.causes_code_bloat(caller, cost)
    }
}
```

### Pass: inlining (7-10 days)

**Purpose**: Replace function calls with function body

**Algorithm**:
1. Build call graph
2. Compute inlining costs
3. Choose functions to inline (bottom-up order)
4. For each call site:
   - Clone callee body
   - Map parameters to arguments
   - Replace call with cloned body
   - Run local opts to clean up

**Example**:
```wasm
;; Before:
(func $add (param $a i32) (param $b i32) (result i32)
  (i32.add (local.get $a) (local.get $b))
)
(func $main
  (call $add (i32.const 1) (i32.const 2))
)

;; After:
(func $main
  (i32.add (i32.const 1) (i32.const 2))
)
;; $add removed (no longer called)
```

**C++ Reference**: `src/passes/Inlining.cpp` (~600 lines), `src/passes/InliningOptimizing.cpp` (~650 lines)

**Testing**:
- Simple function inlining
- Parameter mapping
- Multiple call sites
- Recursive functions (should not inline)
- Code size impact measurement

---

### Pass: duplicate-function-elimination (3-4 days)

**Purpose**: Find and merge identical functions

**Algorithm**:
1. Compute hash for each function body
2. Group functions by hash
3. For identical functions, keep one and redirect all calls
4. Remove duplicates

**C++ Reference**: `src/passes/DuplicateFunctionElimination.cpp` (~300 lines)

---

## Group 4B: Data Flow & SSA Analysis

**Passes**: 8 | **Effort**: 24-32 days

### Pass List
1. **dfo** (dataflow-opts) â€” SSA-based optimizations
2. **flatten** (also in Tier 2B) â€” Convert to flat IR for SSA
3. **type-ssa** â€” Track types in SSA form
4. **gsi** (global-struct-inference) â€” Infer struct layouts
5. **cfp** / **cfp-reftest** (constant-field-propagation) â€” Propagate constant fields
6. **unsubtyping** â€” Remove unnecessary subtype relations
7. **local-subtyping** (also in Tier 2A/3C) â€” Refine via SSA
8. **gufa** â€” Global unreachable function analysis

### Shared Infrastructure: SSA Construction (4-5 days)

```rust
// rust/binaryen-ir/src/analysis/ssa.rs

pub struct SSABuilder<'a> {
    arena: &'a Bump,
    /// Phi nodes inserted at merge points
    phi_nodes: HashMap<BlockId, Vec<PhiNode>>,
    /// Mapping from original local to SSA version
    versions: HashMap<LocalId, Vec<ExprRef>>,
}

pub struct PhiNode {
    pub result_local: LocalId,
    pub incoming: Vec<(BlockId, ExprRef)>,
}

impl<'a> SSABuilder<'a> {
    /// Convert function to SSA form
    pub fn build(func: &mut Function, cfg: &ControlFlowGraph, dom: &DominanceTree) -> Self {
        // 1. Insert phi nodes at dominance frontiers
        // 2. Rename variables (each assignment creates new version)
        // 3. Update uses to reference correct version
    }
}
```

### Pass: dfo (dataflow-opts) (5-7 days)

**Purpose**: SSA-based optimizations (dead code elimination, copy propagation, etc.)

**Requires**: Flatten pass (convert to flat IR), then SSA construction

**Algorithm**:
1. Build SSA
2. Eliminate dead code (unused definitions)
3. Propagate copies (local.set $x (local.get $y) â†’ replace $x with $y)
4. Constant propagation through phi nodes
5. Convert back from SSA

**C++ Reference**: `src/passes/DataFlowOpts.cpp` (~800 lines)

---

## Group 4C: Global & Module Analysis

**Passes**: 8 | **Effort**: 16-32 days

### Pass List
1. **global-refining** (also in 3C) â€” Narrow global types
2. **generate-global-effects** (also in 3B) â€” Compute whole-module effects
3. **gsi** (also in 4B) â€” Global struct inference
4. **gufa** (also in 4B) â€” Global unreachable function analysis
5. **gto** (global-type-optimization) â€” Optimize GC types globally
6. **remove-unused-module-elements** (also in Tier 1A) â€” Via global analysis
7. **simplify-globals** / **simplify-globals-optimizing** â€” Optimize globals
8. **propagate-globals-globally** â€” Propagate constants globally

### Shared Infrastructure: Global Analysis

```rust
// rust/binaryen-ir/src/analysis/global_analysis.rs

pub struct GlobalAnalysis {
    /// Which globals are constants (never written after init)
    constant_globals: HashSet<GlobalId>,
    
    /// Known values for constant globals
    global_values: HashMap<GlobalId, Literal>,
    
    /// Which functions never called (dead code)
    unreachable_functions: HashSet<FunctionId>,
}

impl GlobalAnalysis {
    pub fn analyze(module: &Module, call_graph: &CallGraph) -> Self {
        // Scan all functions for global.set operations
        // Identify globals that are set-once or never-written
        // Propagate known values through global.get
    }
}
```

### Pass: simplify-globals (3-4 days)

**Purpose**: Optimize global variable usage

**Patterns**:
- Remove write-only globals
- Inline constant globals
- Coalesce redundant globals
- Remove unused globals

**C++ Reference**: `src/passes/SimplifyGlobals.cpp` (~400 lines)

---

## Group 4D: Type System & GC

**Passes**: 5 | **Effort**: 10-20 days

### Pass List
1. **type-merging** â€” Merge compatible types
2. **minimize-rec-groups** â€” Split types into minimal recursion groups
3. **type-generalizing** â€” Generalize types for better compression
4. **signature-pruning** / **signature-refining** â€” Optimize function signatures
5. **heap-store-optimization** â€” Optimize struct/array stores

### Implementation Notes

GC-focused passes that work on WebAssembly GC types (structs, arrays, references).

**Key Infrastructure**:
- Type compatibility analysis
- Recursive type group management
- Heap type tracking

**C++ References**: 
- `src/passes/TypeMerging.cpp` (~500 lines)
- `src/passes/MinimizeRecGroups.cpp` (~300 lines)
- `src/passes/HeapStoreOptimization.cpp` (~400 lines)

---

## Tier 4 Timeline

**Week 15-16**: Infrastructure
- Week 15: CallGraph + CostEstimator
- Week 16: SSA construction infrastructure

**Week 17-18**: Inlining
- Implement inlining + inlining-optimizing
- Duplicate function elimination

**Week 19-20**: SSA-based opts
- Flatten + dfo
- Type-ssa + related passes

**Week 21**: Global analysis
- Global refining + simplify-globals

**Week 22**: Type/GC passes
- Type merging + heap optimizations

---

## Success Criteria

### Quantitative
- âœ… 28 passes implemented (48 â†’ 76 total)
- âœ… Functional parity: ~75% of C++ capability
- âœ… Performance improvement: 10-50% from inlining
- âœ… Call graph + SSA infrastructure complete

### Qualitative
- âœ… Whole-module optimization pipeline functional
- âœ… Inlining delivers major performance wins
- âœ… SSA enables advanced data flow analysis

---

## Next Steps

With Tier 4 complete, you have **production-grade optimization capability** covering most real-world use cases.

**Natural progression**: Move to **Tier 5 (Specialized & Backend)** for ecosystem integration (Emscripten, feature lowering, etc.).

See `2.5-tier5-specialized.md` for details.

---

### Maturity Analysis (Critical Audit)

### Precipitous Summary
Tier 4 has transitioned from a structural port to a functional optimization suite. The **infrastructure** (CallGraph, CFG, SSA with Def-Use) is now complete and powering high-impact transforms. Core logic for type refinement (`GlobalRefining`, `LocalSubtyping`) is functional thanks to the expansion of the Type system API.

**Conclusion**: The "Muscle" has been heavily developed. While GC-specific global flow (GUFA) and full inlining heuristics remain, the primary dataflow and refinement passes are now production-capable for MVP and basic GC types.

### Maturity Matrix

| Pass | Rust File | C++ File (Ref) | Maturity % | Status | Notes |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Inlining** | `inlining.rs` | [Inlining.cpp](../../../src/passes/Inlining.cpp) | 40% | **Partial** | Full body cloning functional; missing advanced heuristics/inlining-optimizing. |
| **DFO (DataFlowOpts)** | `dfo.rs` | [DataFlowOpts.cpp](../../../src/passes/DataFlowOpts.cpp) | 65% | **Heavy** | SSA-based DSE and Constant Prop implemented; missing generalized copy prop. |
| **Flatten** | `flatten.rs` | [Flatten.cpp](../../../src/passes/Flatten.cpp) | 95% | **Complete** | Production-ready flattening; handles all control flow and side-effects. |
| **Duplicate Func Elim**| `duplicate_function_elimination.rs` | [DuplicateFunctionElimination.cpp](../../../src/passes/DuplicateFunctionElimination.cpp) | 90% | **Complete** | Stable hashing and redirection with full unit tests. |
| **Global Refining** | `global_refining.rs` | [GlobalRefining.cpp](../../../src/passes/GlobalRefining.cpp) | 80% | **Heavy** | Functional LUB-based type refinement using new Type API. |
| **Simplify Globals** | `simplify_globals.rs` | [SimplifyGlobals.cpp](../../../src/passes/SimplifyGlobals.cpp) | 45% | **Partial** | Constant propagation functional; rewriter is shallow; missing global removal. |
| **Signature Pruning** | `signature_pruning.rs` | [SignaturePruning.cpp](../../../src/passes/SignaturePruning.cpp) | 95% | **Complete** | High-fidelity pruning of unused/constant parameters and call-site updates. |
| **Local Subtyping** | `local_subtyping.rs` | [LocalSubtyping.cpp](../../../src/passes/LocalSubtyping.cpp) | 60% | **Partial** | Flow-insensitive visitor based; **missing true SSA-based refinement**. |
| **Type SSA** | N/A | [TypeSSA.cpp](../../../src/passes/TypeSSA.cpp) | 0% | **Missing** | To be implemented in next phase for specialized GC support. |
| **GUFA** | N/A | [GUFA.cpp](../../../src/passes/GUFA.cpp) | 0% | **Missing** | Global Unified Flow Analysis not started. |

---

## Current Gap Analysis

The primary structural gaps have been closed with the addition of **Def-Use chains** in SSA and **Subtyping/LUB logic** in the core Type store. Remaining work focuses on **upgrading LocalSubtyping to use the SSA infrastructure**, **specialized GC optimizations** (TypeSSA, GTO), and **advanced global analysis** (GUFA). The **Inlining** pass is functional but requires the 500+ lines of specialized heuristics from C++ to reach full maturity.

